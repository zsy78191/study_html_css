<!doctype html>
<html class="no-js" lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>
    
  zsy78191
  

  </title>
  <link href="atom.xml" rel="alternate" title="zsy78191" type="application/atom+xml">
    <link rel="stylesheet" href="asset/css/foundation.min.css" />
    <link rel="stylesheet" href="asset/css/docs.css" />
    <script src="asset/js/vendor/modernizr.js"></script>
    <script src="asset/js/vendor/jquery.js"></script>
  <script src="asset/highlightjs/highlight.pack.js"></script>
  <link href="asset/highlightjs/styles/github.css" media="screen, projection" rel="stylesheet" type="text/css">
  <script>hljs.initHighlightingOnLoad();</script>

  </head>
  <body class="antialiased hide-extras">
    
    <div class="marketing off-canvas-wrap" data-offcanvas>
      <div class="inner-wrap">


<nav class="top-bar docs-bar hide-for-small" data-topbar>


  <section class="top-bar-section">
  <div class="row">
      <div style="position: relative;width:100%;"><div style="position: absolute; width:100%;">
        <ul id="main-menu" class="left">
        <li id="menu_item_index"><a href="index.html">HOME</a></li>
        <li id="menu_item_archives"><a href="archives.html">Archives</a></li>
        <li id="menu_item_about"><a href="about.html">ABOUT</a></li>
        </ul>

        <ul class="right" id="search-wrap">
          <li>
<form target="_blank" action="http://google.com/search" method="get">
    <input type="hidden" name="q" value="site:" />
    <input tabindex="1" type="search" name="q"  placeholder="Search"/>
</form>
</li>
          </ul>
      </div></div>
  </div>
  </section>

</nav>

        <nav class="tab-bar show-for-small">
  <a href="javascript:void(0)" class="left-off-canvas-toggle menu-icon">
    <span> &nbsp; zsy78191</span>
  </a>
</nav>

<aside class="left-off-canvas-menu">
      <ul class="off-canvas-list">
       
       <li><a href="index.html">HOME</a></li>
    <li><a href="archives.html">Archives</a></li>
    <li><a href="about.html">ABOUT</a></li>

    <li><label>Categories</label></li>

        
            <li><a href="%E5%8F%82%E8%80%83.html">参考</a></li>
        
            <li><a href="Note.html">Note</a></li>
         

      </ul>
    </aside>

<a class="exit-off-canvas" href="#"></a>


        <section id="main-content" role="main" class="scroll-container">
 <script type="text/javascript">
	$(function(){
		$('#menu_item_index').addClass('is_active');
	});
</script>
<div class="row">
	<div class="large-8 medium-8 columns">
		<div class="markdown-body home-categories">
		
			<div class="article">
                <a class="clearlink" href="14543937535743.html">
                
                  <h1></h1>
                  <div class="a-content">
                      
                      <div class="a-content-text">
                        
                        	<p>2016-02-02 14:13:49.030 Yueke[3403:1489026] 1 食品饮料<br/>
2016-02-02 14:13:49.030 Yueke[3403:1489026] 10 其它糖果<br/>
2016-02-02 14:13:49.031 Yueke[3403:1489026] 100 冷冻食品<br/>
2016-02-02 14:13:49.031 Yueke[3403:1489026] 101 冷冻水饺<br/>
2016-02-02 14:13:49.031 Yueke[3403:1489026] 102 冷冻汤圆<br/>
2016-02-02 14:13:49.031 Yueke[3403:1489026] 11 蜜饯<br/>
2016-02-02 14:13:49.037 Yueke[3403:1489026] 110 酒水<br/>
2016-02-02 14:13:49.037 Yueke[3403:1489026] 111 烈酒<br/>
2016-02-02 14:13:49.037 Yueke[3403:1489026] 113 进口红酒<br/>
2016-02-02 14:13:49.037 Yueke[3403:1489026] 114 国产烈酒<br/>
2016-02-02 14:13:49.038 Yueke[3403:1489026] 115 国产红酒<br/>
2016-02-02 14:13:49.038 Yueke[3403:1489026] 116 烟<br/>
2016-02-02 14:13:49.038 Yueke[3403:1489026] 118 打火机<br/>
2016-02-02 14:13:49.039 Yueke[3403:1489026] 12 瓜子<br/>
2016-02-02 14:13:49.040 Yueke[3403:1489026] 120 啤酒<br/>
2016-02-02 14:13:49.040 Yueke[3403:1489026] 121 进口啤酒<br/>
2016-02-02 14:13:49.040 Yueke[3403:1489026] 122 国产啤酒<br/>
2016-02-02 14:13:49.042 Yueke[3403:1489026] 123 其他酒类<br/>
2016-02-02 14:13:49.042 Yueke[3403:1489026] 124 其他酒类<br/>
2016-02-02 14:13:49.042 Yueke[3403:1489026] 125 速食快餐<br/>
2016-02-02 14:13:49.043 Yueke[3403:1489026] 126 速食快餐<br/>
2016-02-02 14:13:49.043 Yueke[3403:1489026] 129 茶叶蛋<br/>
2016-02-02 14:13:49.043 Yueke[3403:1489026] 13 花生<br/>
2016-02-02 14:13:49.046 Yueke[3403:1489026] 131 香肠<br/>
2016-02-02 14:13:49.046 Yueke[3403:1489026] 133 盒餐便当<br/>
2016-02-02 14:13:49.046 Yueke[3403:1489026] 134 包子<br/>
2016-02-02 14:13:49.046 Yueke[3403:1489026] 135 花卷、馒头<br/>
2016-02-02 14:13:49.047 Yueke[3403:1489026] 136 关东煮<br/>
2016-02-02 14:13:49.047 Yueke[3403:1489026] 137 粥<br/>
2016-02-02 14:13:49.048 Yueke[3403:1489026] 139 生鲜<br/>
2016-02-02 14:13:49.048 Yueke[3403:1489026] 14 洋芋片<br/>
2016-02-02 14:13:49.052 Yueke[3403:1489026] 141 其它速食<br/>
2016-02-02 14:13:49.052 Yueke[3403:1489026] 142 洗护清洁<br/>
2016-02-02 14:13:49.053 Yueke[3403:1489026] 143 日化保健<br/>
2016-02-02 14:13:49.053 Yueke[3403:1489026] 144 洗发水<br/>
2016-02-02 14:13:49.054 Yueke[3403:1489026] 145 沐浴乳<br/>
2016-02-02 14:13:49.054 Yueke[3403:1489026] 146 定型发胶<br/>
2016-02-02 14:13:49.054 Yueke[3403:1489026] 147 牙膏牙刷<br/>
2016-02-02 14:13:49.057 Yueke[3403:1489026] 15 坚果<br/>
2016-02-02 14:13:49.057 Yueke[3403:1489026] 150 洗面奶<br/>
2016-02-02 14:13:49.058 Yueke[3403:1489026] 151 刮胡用品<br/>
2016-02-02 14:13:49.058 Yueke[3403:1489026] 152 香皂<br/>
2016-02-02 14:13:49.058 Yueke[3403:1489026] 153 其它日化<br/>
2016-02-02 14:13:49.058 Yueke[3403:1489026] 154 保养品<br/>
2016-02-02 14:13:49.058 Yueke[3403:1489026] 156 保险套<br/>
2016-02-02 14:13:49.059 Yueke[3403:1489026] 158 护发用品<br/>
2016-02-02 14:13:49.059 Yueke[3403:1489026] 16 豆干<br/>
2016-02-02 14:13:49.059 Yueke[3403:1489026] 163 纸质商品<br/>
2016-02-02 14:13:49.059 Yueke[3403:1489026] 164 卫生纸<br/>
2016-02-02 14:13:49.059 Yueke[3403:1489026] 165 卫生巾<br/>
2016-02-02 14:13:49.059 Yueke[3403:1489026] 166 护垫<br/>
2016-02-02 14:13:49.060 Yueke[3403:1489026] 167 盒装面纸<br/>
2016-02-02 14:13:49.062 Yueke[3403:1489026] 168 湿纸巾<br/>
2016-02-02 14:13:49.062 Yueke[3403:1489026] 169 纸尿裤<br/>
2016-02-02 14:13:49.062 Yueke[3403:1489026] 17 果冻<br/>
2016-02-02 14:13:49.062 Yueke[3403:1489026] 170 其它纸品<br/>
2016-02-02 14:13:49.062 Yueke[3403:1489026] 171 家居用品<br/>
2016-02-02 14:13:49.062 Yueke[3403:1489026] 172 家庭用品<br/>
2016-02-02 14:13:49.063 Yueke[3403:1489026] 173 洗衣用品<br/>
2016-02-02 14:13:49.069 Yueke[3403:1489026] 174 漂白剂<br/>
2016-02-02 14:13:49.069 Yueke[3403:1489026] 175 皮革保养<br/>
2016-02-02 14:13:49.069 Yueke[3403:1489026] 177 雨具<br/>
2016-02-02 14:13:49.070 Yueke[3403:1489026] 178 厕浴清洁<br/>
2016-02-02 14:13:49.070 Yueke[3403:1489026] 179 厨房清洁<br/>
2016-02-02 14:13:49.070 Yueke[3403:1489026] 18 袋装熟食<br/>
2016-02-02 14:13:49.070 Yueke[3403:1489026] 180 清香剂<br/>
2016-02-02 14:13:49.073 Yueke[3403:1489026] 182 纺织用品<br/>
2016-02-02 14:13:49.074 Yueke[3403:1489026] 183 毛巾浴巾<br/>
2016-02-02 14:13:49.074 Yueke[3403:1489026] 184 内衣/裤<br/>
2016-02-02 14:13:49.074 Yueke[3403:1489026] 185 袜子<br/>
2016-02-02 14:13:49.075 Yueke[3403:1489026] 19 膨化食品<br/>
2016-02-02 14:13:49.075 Yueke[3403:1489026] 191 文具玩具<br/>
2016-02-02 14:13:49.075 Yueke[3403:1489026] 192 纸<br/>
2016-02-02 14:13:49.075 Yueke[3403:1489026] 193 笔<br/>
2016-02-02 14:13:49.076 Yueke[3403:1489026] 194 本<br/>
2016-02-02 14:13:49.076 Yueke[3403:1489026] 196 学生用文具<br/>
2016-02-02 14:13:49.076 Yueke[3403:1489026] 197 办公用品<br/>
2016-02-02 14:13:49.076 Yueke[3403:1489026] 2 糖果零食<br/>
2016-02-02 14:13:49.076 Yueke[3403:1489026] 20 其它零食<br/>
2016-02-02 14:13:49.077 Yueke[3403:1489026] 200 电动玩具<br/>
2016-02-02 14:13:49.077 Yueke[3403:1489026] 202 洋娃娃<br/>
2016-02-02 14:13:49.077 Yueke[3403:1489026] 205 玩具枪<br/>
2016-02-02 14:13:49.077 Yueke[3403:1489026] 208 其它玩具<br/>
2016-02-02 14:13:49.078 Yueke[3403:1489026] 209 五金塑料<br/>
2016-02-02 14:13:49.079 Yueke[3403:1489026] 210 锅碗瓢盆<br/>
2016-02-02 14:13:49.079 Yueke[3403:1489026] 211 水具<br/>
2016-02-02 14:13:49.079 Yueke[3403:1489026] 212 餐具<br/>
2016-02-02 14:13:49.079 Yueke[3403:1489026] 214 水杯<br/>
2016-02-02 14:13:49.080 Yueke[3403:1489026] 215 卫浴<br/>
2016-02-02 14:13:49.081 Yueke[3403:1489026] 216 清洁工具<br/>
2016-02-02 14:13:49.081 Yueke[3403:1489026] 217 一次性用品<br/>
2016-02-02 14:13:49.081 Yueke[3403:1489026] 22 特产<br/>
2016-02-02 14:13:49.082 Yueke[3403:1489026] 220 小家电<br/>
2016-02-02 14:13:49.082 Yueke[3403:1489026] 221 五金用品<br/>
2016-02-02 14:13:49.082 Yueke[3403:1489026] 222 电池<br/>
2016-02-02 14:13:49.085 Yueke[3403:1489026] 23 饮料乳品<br/>
2016-02-02 14:13:49.086 Yueke[3403:1489026] 24 可乐<br/>
2016-02-02 14:13:49.086 Yueke[3403:1489026] 25 果汁<br/>
2016-02-02 14:13:49.086 Yueke[3403:1489026] 26 苏打水<br/>
2016-02-02 14:13:49.086 Yueke[3403:1489026] 27 饮用水<br/>
2016-02-02 14:13:49.087 Yueke[3403:1489026] 28 茶<br/>
2016-02-02 14:13:49.087 Yueke[3403:1489026] 29 纯果汁<br/>
2016-02-02 14:13:49.089 Yueke[3403:1489026] 3 口香糖<br/>
2016-02-02 14:13:49.089 Yueke[3403:1489026] 30 咖啡饮料<br/>
2016-02-02 14:13:49.089 Yueke[3403:1489026] 31 机能饮料<br/>
2016-02-02 14:13:49.090 Yueke[3403:1489026] 32 含乳饮料<br/>
2016-02-02 14:13:49.090 Yueke[3403:1489026] 33 其它饮料<br/>
2016-02-02 14:13:49.090 Yueke[3403:1489026] 34 嗜好补品<br/>
2016-02-02 14:13:49.090 Yueke[3403:1489026] 35 茶叶<br/>
2016-02-02 14:13:49.092 Yueke[3403:1489026] 36 咖啡<br/>
2016-02-02 14:13:49.093 Yueke[3403:1489026] 39 健康食品<br/>
2016-02-02 14:13:49.093 Yueke[3403:1489026] 4 爽喉糖<br/>
2016-02-02 14:13:49.093 Yueke[3403:1489026] 40 蜂蜜<br/>
2016-02-02 14:13:49.093 Yueke[3403:1489026] 43 奶粉<br/>
2016-02-02 14:13:49.093 Yueke[3403:1489026] 44 麦片<br/>
2016-02-02 14:13:49.093 Yueke[3403:1489026] 49 奶茶<br/>
2016-02-02 14:13:49.096 Yueke[3403:1489026] 5 巧克力<br/>
2016-02-02 14:13:49.096 Yueke[3403:1489026] 50 其它补品<br/>
2016-02-02 14:13:49.096 Yueke[3403:1489026] 51 面包<br/>
2016-02-02 14:13:49.096 Yueke[3403:1489026] 52 土司<br/>
2016-02-02 14:13:49.096 Yueke[3403:1489026] 54 甜面包<br/>
2016-02-02 14:13:49.097 Yueke[3403:1489026] 58 沙拉酱<br/>
2016-02-02 14:13:49.097 Yueke[3403:1489026] 59 其它西式快餐<br/>
2016-02-02 14:13:49.099 Yueke[3403:1489026] 6 软糖<br/>
2016-02-02 14:13:49.099 Yueke[3403:1489026] 60 肉制品<br/>
2016-02-02 14:13:49.099 Yueke[3403:1489026] 61 火腿肠<br/>
2016-02-02 14:13:49.100 Yueke[3403:1489026] 62 奶<br/>
2016-02-02 14:13:49.100 Yueke[3403:1489026] 64 纯奶<br/>
2016-02-02 14:13:49.100 Yueke[3403:1489026] 65 调味奶<br/>
2016-02-02 14:13:49.100 Yueke[3403:1489026] 67 酸奶<br/>
2016-02-02 14:13:49.103 Yueke[3403:1489026] 68 豆奶<br/>
2016-02-02 14:13:49.103 Yueke[3403:1489026] 7 玩具糖果<br/>
2016-02-02 14:13:49.103 Yueke[3403:1489026] 70 面食饼干<br/>
2016-02-02 14:13:49.103 Yueke[3403:1489026] 71 桶面<br/>
2016-02-02 14:13:49.103 Yueke[3403:1489026] 72 杯面<br/>
2016-02-02 14:13:49.103 Yueke[3403:1489026] 73 袋装面<br/>
2016-02-02 14:13:49.104 Yueke[3403:1489026] 74 面条<br/>
2016-02-02 14:13:49.106 Yueke[3403:1489026] 76 零嘴面<br/>
2016-02-02 14:13:49.107 Yueke[3403:1489026] 77 速食粥<br/>
2016-02-02 14:13:49.108 Yueke[3403:1489026] 78 其它面食<br/>
2016-02-02 14:13:49.109 Yueke[3403:1489026] 79 夹心饼干<br/>
2016-02-02 14:13:49.111 Yueke[3403:1489026] 80 单片饼干<br/>
2016-02-02 14:13:49.112 Yueke[3403:1489026] 82 派类<br/>
2016-02-02 14:13:49.113 Yueke[3403:1489026] 83 其它饼干<br/>
2016-02-02 14:13:49.114 Yueke[3403:1489026] 84 粮油副食<br/>
2016-02-02 14:13:49.115 Yueke[3403:1489026] 85 烘培调料<br/>
2016-02-02 14:13:49.116 Yueke[3403:1489026] 86 罐头食品<br/>
2016-02-02 14:13:49.117 Yueke[3403:1489026] 87 佐餐酱菜<br/>
2016-02-02 14:13:49.118 Yueke[3403:1489026] 88 酱油、醋<br/>
2016-02-02 14:13:49.119 Yueke[3403:1489026] 89 调味品<br/>
2016-02-02 14:13:49.120 Yueke[3403:1489026] 90 调理包<br/>
2016-02-02 14:13:49.122 Yueke[3403:1489026] 93 包装米<br/>
2016-02-02 14:13:49.123 Yueke[3403:1489026] 95 面粉<br/>
2016-02-02 14:13:49.123 Yueke[3403:1489026] 96 食用油、香油<br/>
2016-02-02 14:13:49.124 Yueke[3403:1489026] 97 挂面<br/>
2016-02-02 14:13:49.124 Yueke[3403:1489026] 99 其它粮油</p>

<p>王艺鹤 <br/>
张凯<br/>
杨林<br/>
张超<br/>
窦露露<br/>
张书豪<br/>
严文</p>

<p>酒水 cate_3.jpg<br/>
2016-02-02 15:45:33.638 Yueke[3530:1520871] 速食快餐 cate_4.jpg<br/>
2016-02-02 15:45:33.639 Yueke[3530:1520871] 洗护清洁 cate_5.jpg<br/>
2016-02-02 15:45:33.639 Yueke[3530:1520871] 粮油副食 cate_2.jpg<br/>
2016-02-02 15:45:33.639 Yueke[3530:1520871] 食品饮料 cate_1.jpg<br/>
2016-02-02 15:45:33.640 Yueke[3530:1520871] 家居用品 cate_6.jpg</p>

<p>sudo chown -R $USER:admin /usr/local/include</p>

                        
                      </div>
                  </div>
                </a>
                <div class="read-more clearfix">
                  <div class="more-left left">
                  
                    <span class="date">2016/2/2</span>
                    <span>posted in&nbsp;</span> 
          				  
          					    <span class="posted-in"><a href='%E5%8F%82%E8%80%83.html'>参考</a></span>
          				   
                  </div>
                  <div class="more-right right">
                  <span class="comments">
                      

                       
                  </span>
                  </div>
                </div>
              </div><!-- article -->
        
			<div class="article">
                <a class="clearlink" href="14531716978294.html">
                
                  <h1>悦客接口需求</h1>
                  <div class="a-content">
                      
                      <div class="a-content-text">
                        
                        	<p>返回中最好包含错误码，所有接口错误码统一。</p>

<p>例如 ret = 1 成功   0 失败 -1 -2 -3 ...不同原因</p>

<h2 id="toc_0">登录注册页面</h2>

<ol>
<li><p>注册接口</p>

<p>发送<code>手机号</code> 、<code>密码</code>、<code>验证码</code>，返回个人信息，身份令牌</p></li>
<li><p>验证码接口</p>

<p>发送<code>手机号</code>，返回<code>验证码</code>，也可以不返回，不反回，前端不做验证</p></li>
<li><p>登录接口</p>

<p>发送<code>手机号</code> 、<code>密码</code>，返回个人信息，身份令牌</p></li>
<li><p>修改密码接口</p>

<p>发送<code>手机号</code> 、<code>密码</code>、<code>验证码</code></p></li>
</ol>

<h2 id="toc_1">其它页面</h2>

<ol>
<li><p>热销商品列表接口</p>

<p>需要分页</p></li>
<li><p>我的收藏接口 （用户收藏的商品列表）</p>

<p>需要分页</p></li>
<li><p>销售排行接口</p>

<p>需要分页</p></li>
<li><p>首页活动接口</p></li>
</ol>

<p>首页设计了两个活动栏。</p>

<ol>
<li><p>搜索接口</p>

<p>需要分页</p></li>
<li><p>分类商品接口</p>

<p>需要分页</p></li>
<li><p>分类接口 （如果有一二级分类可以用参数区分）</p></li>
<li><p>购物车列表接口</p></li>
<li><p>商品详细接口</p></li>
<li><p>操作购物车接口</p></li>
<li><p>订单增改查接口</p></li>
<li><p>收货地址增删改查接口</p></li>
</ol>

                        
                      </div>
                  </div>
                </a>
                <div class="read-more clearfix">
                  <div class="more-left left">
                  
                    <span class="date">2016/1/19</span>
                    <span>posted in&nbsp;</span> 
          				  
          					    <span class="posted-in"><a href='%E5%8F%82%E8%80%83.html'>参考</a></span>
          				   
                  </div>
                  <div class="more-right right">
                  <span class="comments">
                      

                       
                  </span>
                  </div>
                </div>
              </div><!-- article -->
        
			<div class="article">
                <a class="clearlink" href="14556955527053.html">
                
                  <h1>1. 编辑地址接口，总是返回 ‘手机号填写有误哦’</h1>
                  <div class="a-content">
                      
                      <div class="a-content-text">
                        
                        	<p><a href="http://2.sock.applinzi.com/androios.php?a=addressEdit&amp;origin=2&amp;timestamp=1455695523&amp;sign=YueKeBianLi&amp;uonly=CAED306DDFFA19DE8D5FFA3C26D784FC0100000000000000F0DA6E3701000000&amp;district=1927&amp;mobile=18305207272&amp;ukey=dzaAXjWpxE7lbsked821&amp;consignee=%E5%BC%A0%E8%B6%85&amp;address=%E6%B1">http://2.sock.applinzi.com/androios.php?a=addressEdit&amp;origin=2&amp;timestamp=1455695523&amp;sign=YueKeBianLi&amp;uonly=CAED306DDFFA19DE8D5FFA3C26D784FC0100000000000000F0DA6E3701000000&amp;district=1927&amp;mobile=18305207272&amp;ukey=dzaAXjWpxE7lbsked821&amp;consignee=%E5%BC%A0%E8%B6%85&amp;address=%E6%B1</a></p>

<ol>
<li>收藏商品接口返回成功，获取接口却获取不到</li>
</ol>

<p>收藏</p>

<p><a href="http://2.sock.applinzi.com/androios.php?a=goodsSetFav&amp;origin=2&amp;timestamp=1455695648&amp;sign=YueKeBianLi&amp;uonly=47EB2393D404A146375182B3C4332E000100000000000000107B013D01000000&amp;gid=4030&amp;ukey=dzaAXjWpxE7lbsked821">http://2.sock.applinzi.com/androios.php?a=goodsSetFav&amp;origin=2&amp;timestamp=1455695648&amp;sign=YueKeBianLi&amp;uonly=47EB2393D404A146375182B3C4332E000100000000000000107B013D01000000&amp;gid=4030&amp;ukey=dzaAXjWpxE7lbsked821</a></p>

<p>获取</p>

<p><a href="http://2.sock.applinzi.com/androios.php?a=goodsGetFav&amp;origin=2&amp;timestamp=1455695663&amp;sign=YueKeBianLi&amp;uonly=EAF4623170D21C67504F527A1FE6C302804F113D010000000000000000000000&amp;ukey=dzaAXjWpxE7lbsked821&amp;page=1">http://2.sock.applinzi.com/androios.php?a=goodsGetFav&amp;origin=2&amp;timestamp=1455695663&amp;sign=YueKeBianLi&amp;uonly=EAF4623170D21C67504F527A1FE6C302804F113D010000000000000000000000&amp;ukey=dzaAXjWpxE7lbsked821&amp;page=1</a></p>

<ol>
<li>默认地址这个属性，前端要怎么控制？</li>
</ol>

                        
                      </div>
                  </div>
                </a>
                <div class="read-more clearfix">
                  <div class="more-left left">
                  
                    <span class="date">2016/2/17</span>
                    <span>posted in&nbsp;</span> 
          				  
          					    <span class="posted-in"><a href='%E5%8F%82%E8%80%83.html'>参考</a></span>
          				   
                  </div>
                  <div class="more-right right">
                  <span class="comments">
                      

                       
                  </span>
                  </div>
                </div>
              </div><!-- article -->
        
			<div class="article">
                <a class="clearlink" href="14502520092955.html">
                
                  <h1>Background Modes Tutorial: Getting Started</h1>
                  <div class="a-content">
                      
                      <div class="a-content-text">
                        
                        	<p>iOS后台模式教程 （一）</p>

<p><a href="http://www.raywenderlich.com/29948/backgrounding-for-ios">原文</a></p>

<h2 id="toc_0">使用场景</h2>

<p>在iOS7之前的系统中，当应用被挂起，拥有连续的10分钟时间来处理之前的任务，然后才会被系统终止。</p>

<p>所以，后台模式有一些特殊的使用场景。例如，更新位置，播放视频音频，和更新服务器请求。x</p>

<h2 id="toc_1">开始</h2>

<p>第一步设置工程中的<code>Capabilities</code>标签栏，打开<code>Background Modes</code>服务。</p>

<p>出现的<code>Modes</code>选项有</p>

<ul>
<li>Audio,AirPlay and Picture in Picture 视频音频播放</li>
<li>Location updates 位置更新</li>
<li>Voice over IP IP电话</li>
<li>Newsstand downloads 杂志下载</li>
<li>External accessory communication 外部附件通信，包括App Watch</li>
<li>Uses Bluetooth LE accessories 蓝牙LE配件</li>
<li>Acts as a Bluetooth LE accessory 作为蓝牙LE配件</li>
<li>Background fetch 后台抓取服务</li>
<li>Remote notifications 远程通知</li>
</ul>

<p>这里介绍几个模式的用法。</p>

<h2 id="toc_2">播放音频</h2>

<p>下面这段代码加入viewDidLoad中，程序开始时会按顺序播放两个mp3文件。在勾选<code>Audio,AirPlay and Picture in Picture</code>后，挂起程序时，音乐还是会继续播放 。</p>

<p>引用</p>

<pre><code>#import &lt;AVFoundation/AVFoundation.h&gt;
</code></pre>

<p>参数</p>

<pre><code>@property (nonatomic, strong) AVQueuePlayer *player;
</code></pre>

<p>viewDidLoad</p>

<pre><code> NSError *sessionError = nil;
    [[AVAudioSession sharedInstance] setCategory:AVAudioSessionCategoryPlayAndRecord error:&amp;sessionError];
    NSArray *queue = @[
                       [AVPlayerItem playerItemWithURL:[[NSBundle mainBundle] URLForResource:@&quot;music&quot; withExtension:@&quot;mp3&quot;]],
                        [AVPlayerItem playerItemWithURL:[[NSBundle mainBundle] URLForResource:@&quot;pop&quot; withExtension:@&quot;mp3&quot;]]];
    
self.player = [[AVQueuePlayer alloc] initWithItems:queue];
self.player.actionAtItemEnd = AVPlayerActionAtItemEndAdvance;
    
[self.player play];
</code></pre>

<h2 id="toc_3">位置服务</h2>

<p>参数</p>

<pre><code>@property (nonatomic, strong) CLLocationManager *locationManager;
@property (nonatomic, strong) NSMutableArray *locations;
</code></pre>

<p>初始化LocationManager</p>

<pre><code>self.locations = [[NSMutableArray alloc] init];
self.locationManager = [[CLLocationManager alloc] init];
self.locationManager.desiredAccuracy = kCLLocationAccuracyBest;
self.locationManager.delegate = self;
</code></pre>

<p>启动位置更新服务</p>

<pre><code>[self.locationManager startUpdatingLocation];
</code></pre>

<p>记录新位置</p>

<pre><code>- (void)locationManager:(CLLocationManager *)manager
    didUpdateToLocation:(CLLocation *)newLocation
           fromLocation:(CLLocation *)oldLocation
{
    // Add another annotation to the map. 
    if (UIApplication.sharedApplication.applicationState == UIApplicationStateActive)
    {
         //前台运行
    else
    {
        //后台运行
        NSLog(@&quot;App is backgrounded. New location is %@&quot;, newLocation);
    }
}
</code></pre>

<h3 id="toc_4">代码解析</h3>

<p>根据 <code>UIApplication.sharedApplication.applicationState == UIApplicationStateActive</code> 可以判断回调过程中，程序是否挂起。记住要勾选<code>Location updates</code>，当你在制作一个跑步或骑车软件时，需要用到这项功能。</p>

<h2 id="toc_5">一般性有限长度任务</h2>

<p>这个宽泛的功能包括上传或者下载任务等。</p>

<pre><code>@property (nonatomic) UIBackgroundTaskIdentifier backgroundTask;
</code></pre>

<pre><code>self.backgroundTask = [[UIApplication sharedApplication] beginBackgroundTaskWithExpirationHandler:^{
//        NSLog(@&quot;Background handler called. Not running background tasks anymore.&quot;);
        [[UIApplication sharedApplication] endBackgroundTask:self.backgroundTask];
        self.backgroundTask = UIBackgroundTaskInvalid;
    }];
</code></pre>

<p>您也可以在任务完成的时候，主动调用<code>[[UIApplication sharedApplication] endBackgroundTask:self.backgroundTask];</code> 终止任务。<br/>
程序会在后台运行，但并不是无限时间。</p>

                        
                      </div>
                  </div>
                </a>
                <div class="read-more clearfix">
                  <div class="more-left left">
                  
                    <span class="date">2015/12/16</span>
                    <span>posted in&nbsp;</span> 
          				  
          					    <span class="posted-in"><a href='Note.html'>Note</a></span>
          				   
                  </div>
                  <div class="more-right right">
                  <span class="comments">
                      

                       
                  </span>
                  </div>
                </div>
              </div><!-- article -->
        
			<div class="article">
                <a class="clearlink" href="14561077487642.html">
                
                  <h1>HTML</h1>
                  <div class="a-content">
                      
                      <div class="a-content-text">
                        
                        	<p><a href="http://www.w3school.com.cn/tags/html_ref_dtd.asp">HTML 元素表，其中列出了每种元素会出现在哪个文档类型中</a></p>

<p><a href="http://shenwang.blog.ustc.edu.cn/css%E9%82%A3%E4%BA%9B%E4%BA%8B%E5%84%BF/">css那些事儿(基础知识和页面布局)</a></p>

                        
                      </div>
                  </div>
                </a>
                <div class="read-more clearfix">
                  <div class="more-left left">
                  
                    <span class="date">2016/2/22</span>
                    <span>posted in&nbsp;</span> 
          				  
          					    <span class="posted-in"><a href='%E5%8F%82%E8%80%83.html'>参考</a></span>
          				   
                  </div>
                  <div class="more-right right">
                  <span class="comments">
                      

                       
                  </span>
                  </div>
                </div>
              </div><!-- article -->
        
			<div class="article">
                <a class="clearlink" href="14510343642124.html">
                
                  <h1>NSFetchedResultsController的简单封装 － UITableView与CoreData的完美结合</h1>
                  <div class="a-content">
                      
                      <div class="a-content-text">
                        
                        	<ul>
<li>
<a href="#toc_0">基本概念MVC与MVVC</a>
<ul>
<li>
<a href="#toc_1">传统MVC Model － View － Controller</a>
</li>
<li>
<a href="#toc_2">MVVC Model － View － Controller - ViewModel</a>
</li>
</ul>
</li>
<li>
<a href="#toc_3">NSFetchedResultsController</a>
<ul>
<li>
<a href="#toc_4">绑定tableView的DataSource</a>
</li>
<li>
<a href="#toc_5">绑定增删改</a>
</li>
</ul>
</li>
</ul>
</li>
<li>
<a href="#toc_6">DEFetchRC</a>
<ul>
<li>
<a href="#toc_7">DETableViewFetchRC初始化</a>
</li>
<li>
<a href="#toc_8">最终效果</a>
</li>
<li>
<a href="#toc_9">总结</a>
</li>
</ul>


<p>本文将简单分析NSFetchedResultsController这个控制器类的用法和开源控件<a href="https://github.com/zsy78191/DEFetchRC">DEFetchRC</a>的使用方法。</p>

<p>如果您在阅读本文时，对CoreData还没有任何基础概念，这里给您推荐一套来自objcio.cn的<a href="http://objcio.cn/issue-4/">CoreData系列教程</a>，相信能对您有所帮助。</p>

<h2 id="toc_0">基本概念MVC与MVVC</h2>

<p>从传统意义的MVC到MVVC的转变，相信大家都厌烦了术语套话，这些设计模式概念用自然语言描述显得十分抽象，我们今天用Cocoa的类来简单描述一下这两种模式。</p>

<h3 id="toc_1">传统MVC Model － View － Controller</h3>

<p>刚入门Cocoa时，我们接触到的最基本的类，就是UIViewController和UIView类，他们对应的MVC模型中的Controller和View,Model(数据模型)则可以是CoreData的数据，网络请求的数据，或者其他一些格式的数据，MVC的运作模式就是Controller将Model内容填入View，View响应交互让Controller处理数据并且修改View。</p>

<h3 id="toc_2">MVVC Model － View － Controller - ViewModel</h3>

<p>经过实战我们发现，Controller的代码量庞大不堪，一方面操作数据，一方面操作View，臃肿不堪，难以维护。所以MVVC模型应运而生，在MVC的基础上，加入了ViewModel概念，这个(些)ViewModel可以作为Controller的属性，剥离Controller中复杂的任务，例如：</p>

<ol>
<li>替Controller实现TableView和CollectionView的回调。</li>
<li>剥离数据库操作</li>
<li>剥离网络请求</li>
</ol>

<p>这样让Controller专注于处理View布局、交互和动画，把任务剥离，降低整体项目的耦合性。</p>

<h2 id="toc_3">NSFetchedResultsController</h2>

<p>基于高度模块化和低耦合性的设计趋势，<code>NSFetchedResultsController</code>类应运而生。<br/>
你可能还不知道这个类可以完成什么工作，头文件中如此描述：<br/>
<code><br/>
This class is intended to efficiently manage the results returned from a Core Data fetch request.<br/>
这个类用于高效地响应CoreData数据变化<br/>
</code></p>

<p>本文的Demo代码见<a href="https://github.com/zsy78191/DEFetchRC">zsy78191/DEFetchRC</a><br/>
初始化代码，这段代码摘自苹果官方模版，我们自建<code>DETableViewFetchRC</code>类用于绑定，这里在DETableViewFetchRC类中实现NSFetchedResultsController相关方法，使用的参数包括<br/>
1. self.entityName 实体名称<br/>
2. self.managedContext CoreData的上下文<br/>
3. self.predicate 检索谓语<br/>
4. self.sortKey 排序键<br/>
5. self.ascending 排序升序或降序<br/>
6. _fetchController.delegate NSFetchedResultsControllerDelegate委托</p>

<pre><code>@property (nonatomic, strong) NSFetchedResultsController* fetchController;

- (NSFetchedResultsController *)fetchController
{
    if (_fetchController != nil) {
        return _fetchController;
    }
    
    NSFetchRequest *fetchRequest = [[NSFetchRequest alloc] init];
    // Edit the entity name as appropriate.
    NSEntityDescription *entity = [NSEntityDescription entityForName:self.entityName inManagedObjectContext:self.managedContext];
    [fetchRequest setEntity:entity];
    
    // Set the batch size to a suitable number.
    [fetchRequest setFetchBatchSize:20];
    [fetchRequest setPredicate:self.predicate];
    
    // Edit the sort key as appropriate.
    NSSortDescriptor *sortDescriptor = [[NSSortDescriptor alloc] initWithKey:self.sortKey ascending:self.ascending];
    NSArray *sortDescriptors = @[sortDescriptor];
    
    [fetchRequest setSortDescriptors:sortDescriptors];
    
    // Edit the section name key path and cache name if appropriate.
    // nil for section name key path means &quot;no sections&quot;.
    _fetchController= [[NSFetchedResultsController alloc] initWithFetchRequest:fetchRequest managedObjectContext:self.managedContext sectionNameKeyPath:nil cacheName:nil];
    _fetchController.delegate = self;
    
    NSError *error = nil;
    if (![_fetchController performFetch:&amp;error]) {
        // Replace this implementation with code to handle the error appropriately.
        // abort() causes the application to generate a crash log and terminate. You should not use this function in a shipping application, although it may be useful during development.
        ////LOGMARK(@&quot;Unresolved error %@, %@&quot;, error, [error userInfo]);
        abort();
    }
    
    return _fetchController;
}
</code></pre>

<p>绑定好的NSFetchedResultsController通过KVO观察CoreData上下文变化，并通知我们修改View，具体实现如下：</p>

<h3 id="toc_4">绑定tableView的DataSource</h3>

<pre><code>- (NSInteger)numberOfSectionsInTableView:(UITableView *)tableView {
    return [[self.fetchController sections] count];
}
</code></pre>

<p><strong>注：NSFetchedResultsController是支持TableView的Section功能的，我们在这个例子中国年并没有使用，读者可以根据需要进行修改。</strong></p>

<pre><code>- (NSInteger)tableView:(UITableView *)tableView numberOfRowsInSection:(NSInteger)section {
    id &lt;NSFetchedResultsSectionInfo&gt; sectionInfo = [self.fetchController sections][section];
    return [sectionInfo numberOfObjects];
}

- (UITableViewCell *)tableView:(UITableView *)tableView cellForRowAtIndexPath:(NSIndexPath *)indexPath {
    if([self checkDataSourceCanResponse:@selector(tableView:cellAtIndexPath:withData:)])
    {
        NSManagedObject *data = [self.fetchController objectAtIndexPath:indexPath];
         
        //在这里处理Cell内容
    }
    return nil;
}
</code></pre>

<h3 id="toc_5">绑定增删改</h3>

<p>这里<code>NSFetchedResultsController</code>提供了NSFetchedResultsControllerDelegate协议，用于绑定Model和View，如下。</p>

<pre><code>#pragma mark - fetch


- (void)controllerWillChangeContent:(NSFetchedResultsController *)controller
{
    [self.tableView beginUpdates];
}

- (void)controller:(NSFetchedResultsController *)controller didChangeSection:(id &lt;NSFetchedResultsSectionInfo&gt;)sectionInfo
           atIndex:(NSUInteger)sectionIndex forChangeType:(NSFetchedResultsChangeType)type
{
    switch(type) {
        case NSFetchedResultsChangeInsert:
            [self.tableView insertSections:[NSIndexSet indexSetWithIndex:sectionIndex] withRowAnimation:UITableViewRowAnimationAutomatic];
            break;
            
        case NSFetchedResultsChangeDelete:
            [self.tableView deleteSections:[NSIndexSet indexSetWithIndex:sectionIndex] withRowAnimation:UITableViewRowAnimationLeft];
            break;
            
        default:
            return;
    }
}

- (void)controller:(NSFetchedResultsController *)controller didChangeObject:(NSManagedObject*)anObject
       atIndexPath:(NSIndexPath *)indexPath forChangeType:(NSFetchedResultsChangeType)type
      newIndexPath:(NSIndexPath *)newIndexPath
{
    UITableView *tableView = self.tableView;
    switch(type) {
        case NSFetchedResultsChangeInsert:
            [tableView insertRowsAtIndexPaths:@[newIndexPath] withRowAnimation:UITableViewRowAnimationAutomatic];
            break;
            
        case NSFetchedResultsChangeDelete:
            [tableView deleteRowsAtIndexPaths:@[indexPath] withRowAnimation:UITableViewRowAnimationLeft];
            break;
            
        case NSFetchedResultsChangeUpdate:
            [tableView reloadRowsAtIndexPaths:@[indexPath] withRowAnimation:UITableViewRowAnimationAutomatic];
            break;
            
        case NSFetchedResultsChangeMove:
            [tableView deleteRowsAtIndexPaths:@[indexPath] withRowAnimation:UITableViewRowAnimationAutomatic];
            [tableView insertRowsAtIndexPaths:@[newIndexPath] withRowAnimation:UITableViewRowAnimationAutomatic];
            break;
    }
}

- (void)controllerDidChangeContent:(NSFetchedResultsController *)controller
{
    [self.tableView endUpdates];
}

</code></pre>

<p>至此，NSFetchedResultsController的基本使用方法都介绍了，接下来介绍一下我做的一个对NSFetchedResultsController的简单封装，<a href="https://github.com/zsy78191/DEFetchRC">zsy78191/DEFetchRC</a>。</p>

<h1 id="toc_6">DEFetchRC</h1>

<p>一个NSFetchedResultsController的简单封装</p>

<p>DETableViewFetchRC将自动绑定CoreData的ManageContext和TableView，绑定好以后，数据的任何变动，包括增删改查，都会自动调用对应Cell的更新，不需要自己写任何代码做通知挂钩等。</p>

<p>Demo中使用Apple的CoreData模版，CoreData的Context在AppDelegate中。</p>

<pre><code>- (NSManagedObjectContext*)managedObjectContext
{
    AppDelegate* delegate = [UIApplication sharedApplication].delegate;
    return delegate.managedObjectContext;
}
</code></pre>

<h2 id="toc_7">DETableViewFetchRC初始化</h2>

<pre><code>@property (nonatomic, strong) DETableViewFetchRC* tableFetchResultController;

- (void)viewDidLoad {
    [super viewDidLoad];
    
    [self.managedObjectContext setUndoManager:[[NSUndoManager alloc] init]];
    
   
    self.tableFetchResultController = [DETableViewFetchRC fetchRCWithView:self.tableView
                                                                  reciver:self
                                                           managedContext:self.managedObjectContext
                                                               entityName:@&quot;Item&quot;
                                                                  sortKey:@&quot;date&quot;
                                                                ascending:YES
                                                                predicate:nil];
}
</code></pre>

<p>其中第一参数输入需要绑定（bind）的 TableView（如果使用DECollectionViewFetchRC则传入CollectionView），第二个参数是DETableViewFetchDelegate的委托，主要用来实现Cell内容填充回调：</p>

<pre><code>- (UITableViewCell *)tableView:(UITableView *)tableView cellAtIndexPath:(NSIndexPath *)indexPath withData:(id)data
{
    Item* item = data;
    UITableViewCell* cell = [tableView dequeueReusableCellWithIdentifier:@&quot;cell&quot; forIndexPath:indexPath];
    cell.textLabel.text = item.title;
    cell.detailTextLabel.text = [item.date description];
    return cell;
}
</code></pre>

<p>这里的CoreData实例名字是Item，有title和date两个属性，分别为NSString和NSDate。</p>

<p>这样就完成了一步绑定，CoreData的Context有变动时自动更新调用Cell更新回调，更新Cell，增删改都自动完成。效果如下：</p>

<h2 id="toc_8">最终效果</h2>

<p><img src="/img/bVrM4J" alt="DEFetchRCDemo.gif"/></p>

<p>详细的代码请参考<a href="https://github.com/zsy78191/DEFetchRC">zsy78191/DEFetchRC</a></p>

<h2 id="toc_9">总结</h2>

<p>本文作为<a href="http://segmentfault.com/a/1190000002498637">怎样降低iOS代码耦合性</a>一文的延伸阅读，介绍了<code>NSFetchedResultsController</code>类的基本使用方法，这个类作为CoreData的辅助控制器，在哲学高度强化了CoreData和TableView的绑定，原理上也适用于CoreData和CollectionView或其它第三方控件的绑定，灵活中不失稳重，值得细细研究一番。</p>

                        
                      </div>
                  </div>
                </a>
                <div class="read-more clearfix">
                  <div class="more-left left">
                  
                    <span class="date">2015/12/25</span>
                    <span>posted in&nbsp;</span> 
          				  
          					    <span class="posted-in"><a href='Note.html'>Note</a></span>
          				   
                  </div>
                  <div class="more-right right">
                  <span class="comments">
                      

                       
                  </span>
                  </div>
                </div>
              </div><!-- article -->
        
			<div class="article">
                <a class="clearlink" href="14513727145273.html">
                
                  <h1>RACSignal的一些常用用法（二）</h1>
                  <div class="a-content">
                      
                      <div class="a-content-text">
                        
                        	<p>上一篇<a href="http://www.jianshu.com/p/12daaa98e0fc">一些常用的RACSignal</a></p>

<p>紧跟上一篇的内容，我们来用一些例子让大家更深刻地理解<code>RACSignal</code>。</p>

<h2 id="toc_0">NSData</h2>

<p>尝试这个例子之前，请在Demo工程的info.plist文件中加入<code>App Transport Security Settings</code>键值，并加入<code>Allow Arbitrary Loads</code>:<code>YES</code>键值对，用来开启iOS下的非安全连接。</p>

<p>NSData + RACSupport.h<br/>
```<br/>
@interface NSData (RACSupport)</p>

<p>// Read the data at the URL using -[NSData initWithContentsOfURL:options:error:].<br/>
// Sends the data or the error.<br/>
// 返回一个URL异步请求的信号量<br/>
// scheduler 不能为空<br/>
+ (RACSignal *)rac_readContentsOfURL:(NSURL *)URL options:(NSDataReadingOptions)options scheduler:(RACScheduler *)scheduler;</p>

<p>@end<br/>
<code><br/>
可以这样用<br/>
</code><br/>
NSURL* url = [NSURL URLWithString:@<q><a href="http://www.jianshu.com">http://www.jianshu.com</a></q>];<br/>
RACSignal* getDataSignal = [NSData rac_readContentsOfURL:url options:NSDataReadingUncached<br/>
                                       scheduler:[RACScheduler mainThreadScheduler]];<br/>
[getDataSignal subscribeNext:<sup>id x</sup> {<br/>
    NSLog(@<q>%@</q>,x);  //这里的x就是NSData数据<br/>
}];<br/>
```</p>

<h3 id="toc_1">map函数</h3>

<p>如果我们使用<code>NSData</code>的<code>rac_readContentsOfURL:url</code>方法下载的是一张图片，我们肯定希望这个Signal最后输出的是<code>UIImage</code>对象，这里就要用到非常常用的<code>map</code>函数。</p>

<p><code>map</code>函数就像<code>signal</code> 管道上的中间处理器，从这里走过的<code>signal</code>都会经过一段处理后，变成新的<code>signal</code>继续传输。而这个处理过程则在<code>map</code>函数中由开发者决定。</p>

<p>将输出<code>NSData</code>的<code>signal</code>转换为输出<code>UIImage</code><br/>
```<br/>
NSURL* url = [NSURL URLWithString:@<q><a href="http://img1.gtimg.com/gamezone/pics/24159/24159840.jpg">http://img1.gtimg.com/gamezone/pics/24159/24159840.jpg</a></q>];<br/>
RACSignal* getDataSignal = [NSData rac_readContentsOfURL:url options:NSDataReadingUncached<br/>
                                       scheduler:[RACScheduler mainThreadScheduler]];</p>

<p>//map函数进行转换<br/>
RACSignal* getImageSignal = [getDataSignal map:<sup>id(id</sup> value) {<br/>
        if (value) {<br/>
            return [UIImage imageWithData:value];<br/>
        }<br/>
        return nil;<br/>
}];</p>

<p>[getImageSignal subscribeNext:<sup>id x</sup> {<br/>
        NSLog(@<q>%@</q>,x);<br/>
}];<br/>
```</p>

<h3 id="toc_2">merge方法</h3>

<p>接着我们提出一个新需求，同时请求三张不同的图片，并将它们发送的信号合并成一条信号量。这里就需要用到信号量的<code>merge</code>方法，如下</p>

<pre><code>NSURL* url = [NSURL URLWithString:@&quot;http://img1.gtimg.com/gamezone/pics/24159/24159840.jpg&quot;];
NSURL* url2 = [NSURL URLWithString:@&quot;http://i3.hoopchina.com.cn/blogfile/201306/29/137247593017986.jpg&quot;];
NSURL* url3 = [NSURL URLWithString:@&quot;http://img.youxile.com/pic/1301/25170237170.jpg&quot;];
RACSignal* getImageSignal1 = [[NSData rac_readContentsOfURL:url
                                                       options:NSDataReadingUncached
                                                     scheduler:[RACScheduler mainThreadScheduler]]
                                 map:^id(id value) {
        if (value) {
            return [UIImage imageWithData:value];
        }
        return nil;
}];
    
RACSignal* getImageSignal2 = [[NSData rac_readContentsOfURL:url2
                                                        options:NSDataReadingUncached
                                                      scheduler:[RACScheduler mainThreadScheduler]]
                                  map:^id(id value) {
                                      if (value) {
                                          return [UIImage imageWithData:value];
                                      }
                                      return nil;
                                  }];
    
RACSignal* getImageSignal3 = [[NSData rac_readContentsOfURL:url3
                                                        options:NSDataReadingUncached
                                                      scheduler:[RACScheduler mainThreadScheduler]]
                                  map:^id(id value) {
                                      if (value) {
                                          return [UIImage imageWithData:value];
                                      }
                                      return nil;
                                  }];

                                 
//合并操作
RACSignal* mergeSignal = [RACSignal merge:@[getImageSignal1,getImageSignal2,getImageSignal3]];
    
    [mergeSignal subscribeNext:^(id x) {
        NSLog(@&quot;%@&quot;,x);
}];```

输出如下:
</code></pre>

<p>2015-12-30 10:19:08.776 Fahu[1354:39991] <UIImage: 0x7f9ce2ac3730>, {450, 600}<br/>
2015-12-30 10:19:08.891 Fahu[1354:39991] <UIImage: 0x7f9ce2b02600>, {500, 687}<br/>
2015-12-30 10:19:09.098 Fahu[1354:39991] <UIImage: 0x7f9ce29a4500>, {500, 346}<br/>
```</p>

<h3 id="toc_3">filter函数</h3>

<p>网络也会有连不上的时候，三张图片中如果有哪一张请求失败，我们并不想让<code>signal</code>发送<code>nil</code>值过来，可以使用filter函数对<code>signal</code>进行筛选。稍微改造一下上面的<code>mergeSignal</code>:</p>

<pre><code>RACSignal* mergeSignal = [[RACSignal merge:@[getImageSignal1,getImageSignal2,getImageSignal3]] filter:^BOOL(id value) {
        return @(!!value);
}];```

注意这里的filter函数返回的是NSNumber型的BOOL值，YES是通过，NO时拒绝通过。

##NSURLConnection

有了`RAC`，一些简单的网络请求都可以不用AF框架了。

NSURLConnection+RACSupport.h
</code></pre>

<ul>
<li>(RACSignal *)rac_sendAsynchronousRequest:(NSURLRequest *)request;```</li>
</ul>

<p>举个例子，还是请求图片<br/>
<code><br/>
NSURL* url = [NSURL URLWithString:@&quot;http://img1.gtimg.com/gamezone/pics/24159/24159840.jpg&quot;];<br/>
    NSURLRequest* request = [NSURLRequest requestWithURL:url];<br/>
    RACSignal* connectionSignal = [NSURLConnection rac_sendAsynchronousRequest:request];<br/>
    [connectionSignal subscribeNext:^(id x) {<br/>
        NSLog(@&quot;%@&quot;,x);<br/>
}];</code></p>

<p>输出<br/>
<code><br/>
 &lt;RACTuple: 0x7f826c071c00&gt;  ...省略</code></p>

<p>注意，这个<code>signal</code>发送的信号量是一个<code>RACTuple</code>对象。</p>

<h3 id="toc_4">RACTuple</h3>

<p><code>RACTuple</code>（元组）类，是<code>RAC</code>中专门用来返回多个返回值的类，这个设计很像swift中的元组。</p>

<p>上面例子中的<code>RACTuple</code>有两个返回值，<code>x[0]</code>是http response的头部信息，<code>x[1]</code>是请求返回的数据，是一个<code>NSData</code>对象。元组类对象的读取方法和数组相同。</p>

<p>下一片文章我们接着聊聊<code>RAC</code>对<code>UIKit</code>进行的扩展。</p>

                        
                      </div>
                  </div>
                </a>
                <div class="read-more clearfix">
                  <div class="more-left left">
                  
                    <span class="date">2015/12/29</span>
                    <span>posted in&nbsp;</span> 
          				  
          					    <span class="posted-in"><a href='%E5%8F%82%E8%80%83.html'>参考</a></span>
          				   
                  </div>
                  <div class="more-right right">
                  <span class="comments">
                      

                       
                  </span>
                  </div>
                </div>
              </div><!-- article -->
        
			<div class="article">
                <a class="clearlink" href="14500756041561.html">
                
                  <h1>SwizzleMethod的黑魔法</h1>
                  <div class="a-content">
                      
                      <div class="a-content-text">
                        
                        	<pre><code>    void swizzleMethod(Class class, SEL originalSelector, SEL swizzledSelector)
    {
        // the method might not exist in the class, but in its superclass
        Method originalMethod = class_getInstanceMethod(class, originalSelector);
        Method swizzledMethod = class_getInstanceMethod(class, swizzledSelector);
        
        // class_addMethod will fail if original method already exists
        BOOL didAddMethod = class_addMethod(class, originalSelector, method_getImplementation(swizzledMethod), method_getTypeEncoding(swizzledMethod));
        
        // the method doesn’t exist and we just added one
        if (didAddMethod) {
            class_replaceMethod(class, swizzledSelector, method_getImplementation(originalMethod), method_getTypeEncoding(originalMethod));
        }
        else {
            method_exchangeImplementations(originalMethod, swizzledMethod);
        }
    }
</code></pre>

<p>上面这个C风格函数，就是SwizzleMethod的核心方法，用来交换Runtime中类和对象的方法接口指针。但是这有什么用呢？</p>

<h2 id="toc_0">你知道有名的第三方库IQKeyboard么？</h2>

<p>这个吊库，不需要引入头文件，不需要调用任何方法就能使用。怎么做到的呢？<br/>
答案是NSObject的 <code>+ (void)load</code>方法。</p>

<p>这个类方法，在软件运行时一定会调用一次，并且不需要调用super方法，因为父类的load方法也一定会调用。</p>

<p>IQKeyboard就是在load方法中初始化的。</p>

<h2 id="toc_1">SwizzleMethod应用实例 —— 无痛手术</h2>

<p>这个比喻并不准确，准确说应该是无痕手术 —— 对方法的无痕手术</p>

<pre><code>+ (void)load
{
    swizzleMethod([AppDelegate class], @selector(application:didFinishLaunchingWithOptions:), @selector(swizzle_application:didFinishLaunchingWithOptions:));
}
</code></pre>

<p>这里，我们把AppDelegate的启动方法更换成了我们自己的swizzle_application:didFinishLaunchingWithOptions方法。两个方法指针互换，然后我们在我们的方法中加入我们需要的代码。</p>

<pre><code>- (BOOL)swizzle_application:(UIApplication *)application didFinishLaunchingWithOptions:(NSDictionary *)launchOptions
{
    //我们需要添加的代码
    //
    return [self swizzle_application:application didFinishLaunchingWithOptions:launchOptions];
}
</code></pre>

<p>注意到了么，结尾我们自己调用<code>swizzle_application:application</code>方法，因为这个这个方法指针实际已经指向<code>AppDelegate</code>的<code>application:didFinishLaunchingWithOptions</code>方法。其他地方掉用<code>AppDelegate</code>的<code>application:didFinishLaunchingWithOptions</code>方法则会指向我们的<code>swizzle_application:application</code>方法，这样我们就在人不知不觉中，向<code>AppDelegate</code>插入了一段代码，这一切不需要AppDelegate引入任何头文件，是不是很Cool？</p>

<p>这样一来就可以把需要放在这里面的各种监测代码初始化，都放到我们的<code>swizzle_application:application</code>方法中，可以给这个方法新建一个类，每次新建工程直接拖进来一起编译，分分钟植入，帅爆一切，点个赞吧。</p>

                        
                      </div>
                  </div>
                </a>
                <div class="read-more clearfix">
                  <div class="more-left left">
                  
                    <span class="date">2015/12/14</span>
                    <span>posted in&nbsp;</span> 
          				  
          					    <span class="posted-in"><a href='Note.html'>Note</a></span>
          				   
                  </div>
                  <div class="more-right right">
                  <span class="comments">
                      

                       
                  </span>
                  </div>
                </div>
              </div><!-- article -->
        
			<div class="article">
                <a class="clearlink" href="14527416808808.html">
                
                  <h1>UINavigationBar的继承与定制</h1>
                  <div class="a-content">
                      
                      <div class="a-content-text">
                        
                        	<p>我们在iOS项目开发中，有些时候需要修改标准控件的样式，我们今天就围绕一个具体项目需求，进行<code>UINavigationBar</code>的继承与改造。</p>

<h1 id="toc_0">UIApperance协议属性定制</h1>

<p>我们在<code>UINavigationBar.h</code>头文件中，看到如下修改NavigationBar背景颜色的属性</p>

<pre><code>@property(nullable, nonatomic,strong) UIColor *barTintColor NS_AVAILABLE_IOS(7_0) UI_APPEARANCE_SELECTOR;  // default is nil
</code></pre>

<p>注意到<code>UI_APPEARANCE_SELECTOR</code>这个宏了么，用这个宏标记的属性，都是可以通过<code>UIApperance</code>协议进行全局设置的属性。说的更直白一点，就是可以一次性，修改项目中所有的这个类的默认属性。</p>

<p>例如在iOS6之前，<code>UILabel</code>的默认背景颜色不是透明色，而是白色。我们就可以使用如下方法，修改<code>UILabel</code>的默认背景色</p>

<pre><code> [[UILabel appearance] setBackgroundColor:[UIColor clearColor]];
</code></pre>

<p><code>UIApperance</code>协议就是这么神奇，所有的UIKit控件都遵守了这个协议，所有标记了<code>UI_APPEARANCE_SELECTOR</code>宏的属性，都可以使用<code>appearance</code>实例修改默认值，是不是很炫酷。</p>

<h1 id="toc_1">项目需求</h1>

<p>上面一段与本文正题无关，下面我们看一下本文的项目需求</p>

<p><img src="/img/bVsd7L" alt="图片描述"/></p>

<h1 id="toc_2">分析</h1>

<p>这个页面就是一个标准的<code>NavigationController</code> + <code>TableViewContoller</code>组合实现的设置页面，导航条和Table的样式需要订制。</p>

<p>前面说到的<code>UIApperance</code>协议是可以实现的，我们换一种更为普遍的方式实现，<strong>继承</strong>。</p>

<p>我们继承<code>UINavigationBar</code>，创建子类<code>FWBar</code>。我们使用storyboard实例化大体框架模型，并将<code>NavigationViewController</code>的<code>NavigationBar</code>设置为我们的<code>FWBar</code>类，并将<code>UITableView</code>设置为<code>Static</code>静态模式，直接编辑了<code>Cell</code>的内容。</p>

<p><img src="/img/bVsd8s" alt="图片描述"/></p>

<p>在<code>FWBar.m</code>中加入如下代码<br/>
```<br/>
- (void)awakeFromNib<br/>
{<br/>
    [self setBackgroundImage:[UIImage new] forBarMetrics:UIBarMetricsCompact];<br/>
    self.shadowImage = [UIImage new];</p>

<pre><code>//把之前的View统统隐藏
[self.subviews enumerateObjectsUsingBlock:^(__kindof UIView * _Nonnull obj, NSUInteger idx, BOOL * _Nonnull stop) {
    [obj setHidden:YES];
}];


[self addSubview:self.fakeBackgroundView];
self.fakeBackgroundView.userInteractionEnabled = NO;
[self sendSubviewToBack:self.fakeBackgroundView];

self.titleTextAttributes = @{
                             NSFontAttributeName: [UIFont fontWithName:@&quot;NotoSansHans-DemiLight&quot; size:16],
                             NSForegroundColorAttributeName:[UIColor colorWithRed:57.0/255 green:207.0/255 blue:218.0/255 alpha:1]
                             };

//rgba(165, 195, 205, 1)
self.tintColor = [UIColor colorWithRed:165.0/255 green:195.0/255 blue:205.0/255 alpha:1];
</code></pre>

<p>}<br/>
```</p>

<p><strong>解释</strong> 因为原生的NaviBar背景View下方有一条灰色的边，这条边不是用layer生成的，我没搞明白是怎么实现的，所以直接将这个View隐藏掉了。顺便吧<code>shadowImage</code>也换成空图。</p>

<p>这里的<code>self.fakeBackgroundView</code>是我们添加的背景，颜色是白色。这里我们将它移到最下层，并且触摸属性关掉，<code>userInteractionEnabled</code>设为<code>NO</code>。</p>

<p><code>titleTextAttributes</code>这个属性，是用来修改title的样式的。</p>

<p><code>tintColor</code>这个属性，是用来修改导航条左右按钮颜色的。</p>

<p>这些操作做完，还不够。</p>

<p><strong>我们无法通过暴露出来的接口修改左右按钮的字体和位置。这也是我们选择继承而不是UIApperance的原因</strong></p>

<h1 id="toc_3">继承大杀器，高度自定义</h1>

<pre><code>- (void)didAddSubview:(UIView *)subview
{
    NSLog(@&quot;%@&quot;,subview);
    if ([subview isKindOfClass:NSClassFromString(@&quot;UINavigationButton&quot;)]) {
        if ([subview isKindOfClass:[UIButton class]]) {
            
            [(UIButton*)subview setAttributedTitle:[[NSAttributedString alloc] initWithString:[(UIButton*)subview titleForState:UIControlStateNormal] attributes:@{
                                                                                                                                                                   NSFontAttributeName: [UIFont fontWithName:@&quot;AvenirNext-Regular&quot; size:17],
                                                                                                                                                                   NSForegroundColorAttributeName:self.tintColor
                                                                                                                                                                   }] forState:UIControlStateNormal];
        }
    }
}

- (void)layoutSubviews
{
    [super layoutSubviews];
    
    [self.subviews enumerateObjectsUsingBlock:^(__kindof UIView * _Nonnull subview, NSUInteger idx, BOOL * _Nonnull stop) {
        if ([subview isKindOfClass:NSClassFromString(@&quot;UINavigationButton&quot;)]) {
            if ([subview isKindOfClass:[UIButton class]] &amp;&amp; subview.frame.origin.x &lt; self.frame.size.width/2) {
                [subview setFrame:({
                    CGRect rect = subview.frame;
                    rect.origin.x = 8;
                    rect.size.width = 69;
                    rect;
                })];
            }
        }
        
    }];
}
</code></pre>

<p><strong>解释</strong> 重写<code>- (void)didAddSubview:(UIView *)subview</code>方法，检测了系统控件根据<code>NavigationItem</code>向<code>NavigationBar</code>添加按钮这个事件，然后对按钮进行甄别，定制。</p>

<p>我们找到<code>Cancel</code>这个按钮，他虽然是<code>UINavigationButton</code>类型，但是一定是继承了<code>UIButton</code>，所以我们直接强转成她的父类，修改其文字字体和frame。</p>

<p>重写<code>layoutSubviews</code>这个方法，是为了实时更新我们的按钮位置。这个其实也可以不更改的，但是我们的项目需求中，<code>Cancel</code>这个字段太长，字体变大以后导致了显示不全，所以我们将这个做按钮的frame变大了。</p>

<p>注意几点</p>

<ol>
<li><p><code>NSClassFromString(@&quot;UINavigationButton&quot;)</code>这个方法是我们无法获取内部类的时候，获取Class类型的方法。<code>UINavigationButton</code>这个类名是NSLog输出时看到的。</p></li>
<li><p>这一段使用了特殊的语法糖，有兴趣了解的参考<a href="http://blog.sunnyxx.com/2014/08/02/objc-weird-code/">这篇sunnyxx大神的博文</a>，全文搜索关键字<code>小括号内联复合表达式</code></p></li>
</ol>

<pre><code>[subview setFrame:({
                    CGRect rect = subview.frame;
                    rect.origin.x = 8;
                    rect.size.width = 69;
                    rect;
                })];
</code></pre>

<p>最后的实现效果。</p>

<p><img src="/img/bVseck" alt="图片描述"/></p>

<h1 id="toc_4">结语</h1>

<p>截屏的效果不是太好，细心的朋友可能会发现，我们的<code>FWBar</code>在<code>TableView</code>向上滑动的过程中会渐出阴影。</p>

<p>我把这段代码分享给大家，但是这段代码偷懒没用KVO，而是用了<code>ReactiveCocoa</code>这个庞大的庞大框架的小小功能，所以，就没放倒教程里。</p>

<pre><code>- (void)didMoveToSuperview
{
    [super didMoveToSuperview];
    
    UIViewController *presentingViewController = [UIApplication sharedApplication].keyWindow.rootViewController;
    while (presentingViewController.presentedViewController) presentingViewController = presentingViewController.presentedViewController;

    __block BOOL has = NO;
    [[presentingViewController childViewControllers] enumerateObjectsUsingBlock:^(__kindof UIViewController * _Nonnull obj, NSUInteger idx, BOOL * _Nonnull stop) {
        if ([obj isKindOfClass:[UINavigationController class]]) {
            [[obj childViewControllers] enumerateObjectsUsingBlock:^(__kindof UIViewController * _Nonnull obj2, NSUInteger idx, BOOL * _Nonnull stop) {
                if ([obj2 isKindOfClass:[UITableViewController class]]) {
                    has = YES;
                    UITableViewController* tVC = obj2;
                    if (self.tableViewOffsetDisposable) {
                        [self.tableViewOffsetDisposable dispose];
                    }
                    self.tableViewOffsetDisposable = [RACObserve(tVC.tableView, contentOffset) subscribeNext:^(id x) {
                        CGPoint p = [x CGPointValue];
                        
                        if (p.y &lt;= 0 &amp;&amp; p.y &gt;= - 64) {
                            self.fakeBackgroundView.layer.shadowOpacity = fabs(64 + p.y) / 64 * 0.7;
                        }
                        else if (p.y &gt; 0)
                        {
                            if (self.fakeBackgroundView.layer.shadowOpacity != 0.7) {
                                self.fakeBackgroundView.layer.shadowOpacity = 0.7;
                            }
                        }
                        else
                        {
                            if (self.fakeBackgroundView.layer.shadowOpacity != 0) {
                                self.fakeBackgroundView.layer.shadowOpacity = 0;
                            }
                        }
                    }];
                }
            }];
        }
    }];
}
</code></pre>

                        
                      </div>
                  </div>
                </a>
                <div class="read-more clearfix">
                  <div class="more-left left">
                  
                    <span class="date">2016/1/14</span>
                    <span>posted in&nbsp;</span> 
          				  
          					    <span class="posted-in"><a href='Note.html'>Note</a></span>
          				   
                  </div>
                  <div class="more-right right">
                  <span class="comments">
                      

                       
                  </span>
                  </div>
                </div>
              </div><!-- article -->
        
			<div class="article">
                <a class="clearlink" href="14509257553074.html">
                
                  <h1>UITableView 编辑模式详解</h1>
                  <div class="a-content">
                      
                      <div class="a-content-text">
                        
                        	<p><code>UITableView</code>的相关编辑操作非常全，今天我们来做一个总结。跟编辑相关的属性和接口有如下，我们一个一个分析，我们先认真阅读一下相关头文件，我根据意思大概翻译了一下注释。</p>

<h2 id="toc_0">属性方法</h2>

<pre><code>@property (nonatomic, getter=isEditing) BOOL editing;                             
// 默认状态是非编辑状态，如果不调用下面接口直接设置，是没有动画的
- (void)setEditing:(BOOL)editing animated:(BOOL)animated;
</code></pre>

<h2 id="toc_1">DataSource</h2>

<pre><code>// 当增减按钮按下时，用来处理数据和UI的回调。
// 8.0版本后加入的UITableViewRowAction不在这个回调的控制范围内，UITableViewRowAction有单独的回调Block。
- (void)tableView:(UITableView *)tableView commitEditingStyle:(UITableViewCellEditingStyle)editingStyle forRowAtIndexPath:(NSIndexPath *)indexPath;

// 这个回调实现了以后，就会出现更换位置的按钮，回调本身用来处理更换位置后的数据交换。
- (void)tableView:(UITableView *)tableView moveRowAtIndexPath:(NSIndexPath *)sourceIndexPath toIndexPath:(NSIndexPath *)destinationIndexPath;

// 这个回调决定了在当前indexPath的Cell是否可以编辑。
- (BOOL)tableView:(UITableView *)tableView canEditRowAtIndexPath:(NSIndexPath *)indexPath;

// 这个回调决定了在当前indexPath的Cell是否可以移动。
- (BOOL)tableView:(UITableView *)tableView canMoveRowAtIndexPath:(NSIndexPath *)indexPath;
</code></pre>

<h2 id="toc_2">Delegate</h2>

<pre><code>// 这个回调很关键，返回Cell的编辑样式。
- (UITableViewCellEditingStyle)tableView:(UITableView *)tableView editingStyleForRowAtIndexPath:(NSIndexPath *)indexPath;

// 删除按钮的文字
- (nullable NSString *)tableView:(UITableView *)tableView titleForDeleteConfirmationButtonForRowAtIndexPath:(NSIndexPath *)indexPath NS_AVAILABLE_IOS(3_0) __TVOS_PROHIBITED;

// 8.0后侧滑菜单的新接口，支持多个侧滑按钮。
- (nullable NSArray&lt;UITableViewRowAction *&gt; *)tableView:(UITableView *)tableView editActionsForRowAtIndexPath:(NSIndexPath *)indexPath NS_AVAILABLE_IOS(8_0) __TVOS_PROHIBITED;

// 这个接口决定编辑状态下的Cell是否需要缩进。
- (BOOL)tableView:(UITableView *)tableView shouldIndentWhileEditingRowAtIndexPath:(NSIndexPath *)indexPath;

// 这是两个状态回调
- (void)tableView:(UITableView*)tableView willBeginEditingRowAtIndexPath:(NSIndexPath *)indexPath __TVOS_PROHIBITED;
- (void)tableView:(UITableView*)tableView didEndEditingRowAtIndexPath:(NSIndexPath *)indexPath __TVOS_PROHIBITED;
</code></pre>

<h2 id="toc_3">编辑状态</h2>

<p><code>UITableView</code>通过editing属性控制编辑状态，调用<code>- (void)setEditing:(BOOL)editing animated:(BOOL)animated</code>接口，可以决定是否使用原生的变换动画。</p>

<p>当调用这个接口，并将editing设为<code>YES</code>是，<code>UITableView</code>将开始询问代理(Delegate)需要编辑哪些Cell，用什么样的方式编辑。</p>

<p>首先调用回调方法<code>- (BOOL)tableView:(UITableView *)tableView canEditRowAtIndexPath:(NSIndexPath *)indexPath;</code>，这里需要返回YES；</p>

<p>然后依次为各个Cell调用<code>- (UITableViewCellEditingStyle)tableView:(UITableView *)tableView editingStyleForRowAtIndexPath:(NSIndexPath *)indexPath;</code>方法获取编辑样式。</p>

<pre><code>typedef NS_ENUM(NSInteger, UITableViewCellEditingStyle) {
    UITableViewCellEditingStyleNone,
    UITableViewCellEditingStyleDelete,
    UITableViewCellEditingStyleInsert
};
</code></pre>

<p>编辑样式枚举有三种，位运算组合则由不同的用途。</p>

<pre><code>UITableViewCellEditingStyleNone 没有编辑样式
UITableViewCellEditingStyleDelete 删除样式 （左边是红色减号）
UITableViewCellEditingStyleInsert 插入样式  (左边是绿色加号)
UITableViewCellEditingStyleDelete|UITableViewCellEditingStyleInsert 多选模式，左边是蓝色对号
</code></pre>

<p>特别注意，右边的移动并不是这里控制的，需要实现下面这个回调才会出现。<br/>
<code><br/>
- (void)tableView:(UITableView *)tableView moveRowAtIndexPath:(NSIndexPath *)sourceIndexPath toIndexPath:(NSIndexPath *)destinationIndexPath;<br/>
</code></p>

<p>另外对于新手来说，要明白这里的回调都没有对UI和数据进行操作，开发者需要在回调中，完成相应的操作。比如删除或者添加一条数据，应在</p>

<pre><code>- (void)tableView:(UITableView *)tableView commitEditingStyle:(UITableViewCellEditingStyle)editingStyle forRowAtIndexPath:(NSIndexPath *)indexPath;
</code></pre>

<p>上面这个回调中，根据editingStyle进行判断，处理对应的UI和数据。</p>

<h2 id="toc_4">数据与UI更新</h2>

<p>数据更新没什么好说的，直接操作数据容器就好，无论是数组、字典还是CoreData数据。UI更新则需要使用TableView的方法，如果需求reloadData无法满足，则必须使用下面的方法</p>

<pre><code>- (void)beginUpdates;   // allow multiple insert/delete of rows and sections to be animated simultaneously. Nestable
- (void)endUpdates;     // only call insert/delete/reload calls or change the editing state inside an update block.  otherwise things like row count, etc. may be invalid.

- (void)insertSections:(NSIndexSet *)sections withRowAnimation:(UITableViewRowAnimation)animation;
- (void)deleteSections:(NSIndexSet *)sections withRowAnimation:(UITableViewRowAnimation)animation;
- (void)reloadSections:(NSIndexSet *)sections withRowAnimation:(UITableViewRowAnimation)animation NS_AVAILABLE_IOS(3_0);
- (void)moveSection:(NSInteger)section toSection:(NSInteger)newSection NS_AVAILABLE_IOS(5_0);

- (void)insertRowsAtIndexPaths:(NSArray&lt;NSIndexPath *&gt; *)indexPaths withRowAnimation:(UITableViewRowAnimation)animation;
- (void)deleteRowsAtIndexPaths:(NSArray&lt;NSIndexPath *&gt; *)indexPaths withRowAnimation:(UITableViewRowAnimation)animation;
- (void)reloadRowsAtIndexPaths:(NSArray&lt;NSIndexPath *&gt; *)indexPaths withRowAnimation:(UITableViewRowAnimation)animation NS_AVAILABLE_IOS(3_0);
- (void)moveRowAtIndexPath:(NSIndexPath *)indexPath toIndexPath:(NSIndexPath *)newIndexPath NS_AVAILABLE_IOS(5_0);
</code></pre>

<p><code>beginUpdates</code>和<code>endUpdates</code>两个方法，在你需要批量处理Cell的时候，用来包裹住你的处理代码，其他方法名字都很直观，不一一介绍了。</p>

<p>最后给大家推荐一个Cocoa框架里的功能强大的类<code>NSFetchedResultsController</code>，用于绑定CoreData数据和<code>UITableView</code>或者<code>UICollectionView</code>，直接封装好所有的UI操作代码，只要数据有变动，UI自动更新，爽的不要不要的，妈妈再也不用担心我的TableView写不好了，下一篇文章我准备详细讲一讲这个有趣的类。</p>

                        
                      </div>
                  </div>
                </a>
                <div class="read-more clearfix">
                  <div class="more-left left">
                  
                    <span class="date">2015/12/24</span>
                    <span>posted in&nbsp;</span> 
          				  
          					    <span class="posted-in"><a href='Note.html'>Note</a></span>
          				   
                  </div>
                  <div class="more-right right">
                  <span class="comments">
                      

                       
                  </span>
                  </div>
                </div>
              </div><!-- article -->
        
			<div class="article">
                <a class="clearlink" href="14508546630670.html">
                
                  <h1>avoscloud 命令行工具</h1>
                  <div class="a-content">
                      
                      <div class="a-content-text">
                        
                        	<p>终端输入显示帮助信息</p>

<pre><code>$ avoscloud -h
Usage: avoscloud [选项] &lt;命令&gt;

  有效的命令列表包括:
    deploy: 部署云引擎代码到 LeanCloud 平台开发环境
    undeploy: 从 LeanCloud 平台清除云引擎部署，包括生产环境和开发环境
    status: 查询当前部署状态
    search &lt;keyword&gt;: 根据关键字查询开发文档
    publish: 发布开发环境代码到生产环境
    new: 创建云引擎项目
    logs: 查看云引擎日志
    clear: 清除本地状态，在输入 app id 或者 master key 错误的情况下使用
    upload &lt;file-or-directory&gt;: 导入文件到 LeanCloud 平台，如果是目录，则会将该目录下的文件递归导入。
    app [list]:  显示当前应用，deploy、status 等命令运行在当前应用上，如果加上 list ，则显示所有的应用信息。
    checkout &lt;app&gt;: 切换到一个应用，deploy、status 等命令将运行在该应用上。
    add &lt;app&gt;: 添加一个应用。
    rm &lt;app&gt;: 移除一个应用。
    cql: 进入 CQL 查询交互。

  Options:

    -h, --help                 output usage information
    -V, --version              output the version number
    -f, --filepath &lt;path&gt;      本地云引擎项目根路径，默认是当前目录。
    -g, --git                  使用定义在管理平台的 git 仓库或者 -u 指定的 git 仓库部署云引擎代码，默认使用本地代码部署。
    -p, --project &lt;app&gt;        命令运行在指定应用上，默认运行在当前应用或者 origin 应用上。
    -l, --local                使用本地代码部署云引擎代码，该选项是默认选中。
    -o, --log &lt;log&gt;            本次部署的提交日志，仅对从本地部署有效。
    -n, --lines &lt;lines&gt;        查看多少行最新的云引擎日志，默认 10 行。
    -t, --tailf                自动刷新云引擎日志，结合 logs 命令使用。
    -r, --revision &lt;revision&gt;  git 的版本号，仅对从 git 仓库部署有效。
    -P, --port &lt;port&gt;          指定本地调试的端口，默认 3000。
</code></pre>

                        
                      </div>
                  </div>
                </a>
                <div class="read-more clearfix">
                  <div class="more-left left">
                  
                    <span class="date">2015/12/23</span>
                    <span>posted in&nbsp;</span> 
          				  
          					    <span class="posted-in"><a href='%E5%8F%82%E8%80%83.html'>参考</a></span>
          				   
                  </div>
                  <div class="more-right right">
                  <span class="comments">
                      

                       
                  </span>
                  </div>
                </div>
              </div><!-- article -->
        
			<div class="article">
                <a class="clearlink" href="14507680404000.html">
                
                  <h1>iOS 本地化入门教程</h1>
                  <div class="a-content">
                      
                      <div class="a-content-text">
                        
                        	<p>iOS应用的本地化原理非常简单，是通过<code>strings</code>类型的文件，为同一种语言的不同翻译设置翻译表，应用再根据用户系统语言自动检索翻译表实现的。</p>

<p>首先普及一些基本概念给新人看。</p>

<h2 id="toc_0">NSBundle</h2>

<p>在iOS应用中，bundle的概念非常重要，可以理解为一些文件的集合，bundle中可以嵌套bundle，外在 形式是.bundle格式的文件，同时编译生成的app包，也是bundle。</p>

<p>为此，苹果的工程师们留下了NSBundle这个类，用于操作bundle内的文件。而NSBundle类中的一些特定方法，则是给一些特定的文件实用的。</p>

<p>例如<code>infoDictionary</code>用于读取bundle中的info.plist文件。<br/>
<code><br/>
@property (nullable, readonly, copy) NSDictionary&lt;NSString *, id&gt; *infoDictionary;<br/>
</code></p>

<p>当然还有我们今天要讲的本地化方法<br/>
<code><br/>
/* Method for retrieving localized strings. */<br/>
- (NSString *)localizedStringForKey:(NSString *)key value:(nullable NSString *)value table:(nullable NSString *)tableName NS_FORMAT_ARGUMENT(1);<br/>
</code></p>

<p>这个方法就是用来读去bundle中本地化字段的方法。而在日常使用中，我们用的更多的是两个简化的宏：</p>

<pre><code>NSLocalizedString(&lt;#key#&gt;, &lt;#comment#&gt;)
NSLocalizedStringFromTable(&lt;#key#&gt;, &lt;#tbl#&gt;, &lt;#comment#&gt;)
</code></pre>

<pre><code>宏定义

#define NSLocalizedString(key, comment) \
        [[NSBundle mainBundle] localizedStringForKey:(key) value:@&quot;&quot; table:nil]
#define NSLocalizedStringFromTable(key, tbl, comment) \
        [[NSBundle mainBundle] localizedStringForKey:(key) value:@&quot;&quot; table:(tbl)]
#define NSLocalizedStringFromTableInBundle(key, tbl, bundle, comment) \
        [bundle localizedStringForKey:(key) value:@&quot;&quot; table:(tbl)]
#define NSLocalizedStringWithDefaultValue(key, tbl, bundle, val, comment) \
        [bundle localizedStringForKey:(key) value:(val) table:(tbl)]
</code></pre>

<p><code>key</code>参数必填，<code>comment</code>作为注释参数，是不影响返回值的，可以传nil。</p>

<h2 id="toc_1">默认本地化文件</h2>

<p>新工程中是不包含本地化文件的，如果要给应用添加本地化，首先需要添加<code>Localizable.strings</code>文件。</p>

<p><img src="/img/bVrH9C" alt="图片描述"/></p>

<p><code>Localizable.strings</code>文件就是本地化文件中的默认文件，名字不要打错哦，当你使用<code>NSLocalizedString(&lt;#key#&gt;, &lt;#comment#&gt;)</code>宏时，不用输入table名称，便是默认使用<code>Localizable.strings</code>文件作为翻译表。</p>

<p>如果你还有其他的翻译表文件，例如other.strings，你可以这样使用<br/>
<code><br/>
NSLocalizedStringFromTable(@&quot;你好&quot;, @&quot;other&quot;, nil)<br/>
</code><br/>
当然现在并不会将你好翻译成其他语言，下一步，你需要设置你的翻译表。</p>

<h2 id="toc_2">Localizable.strings格式</h2>

<p>strings文件的格式非常简单，但如果格式有错，编译器会报错，并且不会提醒你到底哪里错了，所以务必要仔细。如下<br/>
<code><br/>
&quot;你好&quot; = &quot;你好&quot;;<br/>
</code></p>

<ol>
<li>每一行一句，等号前面是key,等号后面是value,引号前不加<code>@</code>，分号结尾。</li>
<li>当添加多种语言后，同一个文件将会有不同语言的副本，存在工程目录下的不同本地化文件夹中，但在xcode中还是以同一个文件显示，但可以下拉切换语言进行编辑。</li>
</ol>

<p>添加本地化语言的方法如下，先选中<code>strings</code>文件，然后又边点击<code>Localize</code>按钮，然后选项中会有Base和English两个选项，确认后，这里会出现多选框，选取哪种语言，便会自动生成对应的副本。</p>

<p><img src="/img/bVrIaO" alt="图片描述"/></p>

<h3 id="toc_3">添加其他语言</h3>

<p>如图选择Project的Info标签，设置Localization选项<br/>
<img src="/img/bVrIa8" alt="图片描述"/></p>

<h2 id="toc_4">实战</h2>

<p>这里我们添加了简体中文和日本本地化，对应的Localizable.strings文件多了两个副本。</p>

<p><img src="/img/bVrIbx" alt="图片描述"/></p>

<p>各个文件中的内容如下</p>

<pre><code>//日语Localizable.strings(Japanese)文件
&quot;你好&quot; ＝ &quot;こんにちは&quot;;

//英语Localizable.strings(English)文件
&quot;你好&quot; ＝ &quot;hello&quot;;

//简体中文Localizable.strings(Simplified)文件
&quot;你好&quot; ＝ &quot;你好&quot;;
</code></pre>

<p>这样一来，当我们在代码中使用<q>你好</q>这个key时，系统便会自动根据我们的系统语言，进行本地化替换，当系统语言并非我们本地化支持的语言时，例如我们并未加入韩语，本地化接口便会把key的默认语言的本地化内容返回，或者根据设备的第二语言进行返回。当使用的key并不存在时，则会把key作为value返回。</p>

<h2 id="toc_5">开源工具</h2>

<p>这里给大家分享一个我写的<a href="https://github.com/zsy78191/SimpleLocalizedTool">开源项目</a>，可以自动给.m和.mm文件，生成对应的翻译表。<br/>
例如代码中使用本地化方法<br/>
<code><br/>
NSString* a = NSLocalizedString(@&quot;这是一个测试&quot;, nil);<br/>
NSString* b = NSLocalizedString(@&quot;第一条是普通本地化, 翻译写入Localizable.strings文件&quot;, nil);<br/>
NSString* c = NSLocalizedString(@&quot;第二条是带注释的语句&quot;, @&quot;这里是这条本地化语句的注释&quot;);<br/>
NSString* d = NSLocalizedStringFromTable(@&quot;第三条是带表名的本地化语句，写在 XXX(表名).strings文件里&quot;, @&quot;OtherFile&quot;,nil);<br/>
NSString* e = NSLocalizedStringFromTable( @&quot;最后一条测试书写规范，空格，特殊符号(\&quot;{@#$)等等&quot;  ,   @&quot;OtherFile&quot;  ,   nil);<br/>
</code></p>

<p>只要将文件拖入SimpleLocalizedTool工具，便会自动生成对应的本地化文件。<br/>
上面的例子中，有使用默认的string文件语句，也有使用<code>OtherFile</code>这个文件名的语句，所以会生成两个文件，内容如下，直接拷贝到工程中吧，是不是很好用呀。</p>

<pre><code>//Localizable.strings

&quot;这是一个测试&quot; = &quot;这是一个测试&quot;;
&quot;第一条是普通本地化, 翻译写入Localizable.strings文件&quot; = &quot;第一条是普通本地化, 翻译写入Localizable.strings文件&quot;;
&quot;第二条是带注释的语句&quot; = &quot;第二条是带注释的语句&quot;;


//OtherFile.strings

&quot;第三条是带表名的本地化语句，写在 XXX(表名).strings文件里&quot; = &quot;第三条是带表名的本地化语句，写在 XXX(表名).strings文件里&quot;;
&quot;最后一条测试书写规范，空格，特殊符号(\&quot;{@#$)等等&quot; = &quot;最后一条测试书写规范，空格，特殊符号(\&quot;{@#$)等等&quot;;
</code></pre>

                        
                      </div>
                  </div>
                </a>
                <div class="read-more clearfix">
                  <div class="more-left left">
                  
                    <span class="date">2015/12/22</span>
                    <span>posted in&nbsp;</span> 
          				  
          					    <span class="posted-in"><a href='Note.html'>Note</a></span>
          				   
                  </div>
                  <div class="more-right right">
                  <span class="comments">
                      

                       
                  </span>
                  </div>
                </div>
              </div><!-- article -->
        
			<div class="article">
                <a class="clearlink" href="14508532042041.html">
                
                  <h1>iOS 本地化进阶教程</h1>
                  <div class="a-content">
                      
                      <div class="a-content-text">
                        
                        	<p>在<a href="http://segmentfault.com/a/1190000004182437">上一篇</a>入门教程中，我们已经介绍了最基本的本地化方法了，接下来我们要来讲讲两种特殊的本地化情况。</p>

<h2 id="toc_0">xib和storyboard本地化</h2>

<p><code>xib</code>和<code>storyboard</code>作为两种不同类型的UI工具，让我们得以摆脱代码布局之苦，他们的本地化，既可以使用上一篇文章中的方法通过代码修改，也可以直接对xib和storyboard文件进行本地化操作，操作类似strings文件的Localize操作，见下图</p>

<p><img src="/img/bVrJBX" alt="图片描述"/></p>

<p>选中文件后，点击右边栏<code>Localize</code>按钮，勾选对应语言。</p>

<p><img src="/img/bVrJB0" alt="图片描述"/></p>

<p>这样我们发现在Storyboard文件中，包含了Chinese版本的Strings文件，内容如下</p>

<pre><code>
/* Class = &quot;UILabel&quot;; text = &quot;用户名&quot;; ObjectID = &quot;8f2-qK-7KS&quot;; */
&quot;8f2-qK-7KS.text&quot; = &quot;用户名&quot;;

/* Class = &quot;UIButton&quot;; normalTitle = &quot;登录或注册&quot;; ObjectID = &quot;ENI-bN-wSs&quot;; */
&quot;ENI-bN-wSs.normalTitle&quot; = &quot;登录或注册&quot;;

/* Class = &quot;UIButton&quot;; normalTitle = &quot;上一步&quot;; ObjectID = &quot;IGn-o3-iJc&quot;; */
&quot;IGn-o3-iJc.normalTitle&quot; = &quot;上一步&quot;;

/* Class = &quot;UILabel&quot;; text = &quot;用户名&quot;; ObjectID = &quot;YHI-In-kPq&quot;; */
&quot;YHI-In-kPq.text&quot; = &quot;用户名&quot;;

/* Class = &quot;UIButton&quot;; normalTitle = &quot;登录或注册&quot;; ObjectID = &quot;hzS-mR-s9E&quot;; */
&quot;hzS-mR-s9E.normalTitle&quot; = &quot;登录或注册&quot;;

/* Class = &quot;UILabel&quot;; text = &quot;标题&quot;; ObjectID = &quot;rjb-sh-ADV&quot;; */
&quot;rjb-sh-ADV.text&quot; = &quot;标题&quot;;

/* Class = &quot;UILabel&quot;; text = &quot;标题&quot;; ObjectID = &quot;wxc-43-QK7&quot;; */
&quot;wxc-43-QK7.text&quot; = &quot;标题&quot;;

/* Class = &quot;UIButton&quot;; normalTitle = &quot;用户使用协议&quot;; ObjectID = &quot;xdy-郭佳-fv1&quot;; */
&quot;xdy-郭佳-fv1.normalTitle&quot; = &quot;用户使用协议&quot;;
</code></pre>

<p>英文作为项目设置的基础语言，直接使用storyboard内容，中文的本地化，则由这个strings文件控制，是不是很简单。</p>

<h2 id="toc_1">info.plist的本地化</h2>

<p>第二种特殊的本地化需求是对info.plist文件进行本地化。具体的最常见的使用场景有：</p>

<ol>
<li>应用名称本地化</li>
<li>定位请求提示语本地化</li>
</ol>

<p>我们知道系统默认的本地化文件名，叫做<code>Localizable.strings</code>，info.plist文件也有自己对应的本地化文件，叫做<code>InfoPlist.strings</code></p>

<p>这个文件需要开发者自己添加，我们添加好以后，在info.plist中加入｀CFBundleDisplayName｀键值，这个键值决定应用显示的名字。</p>

<p>接下来在InfoPlist.strings文件中写入本地化索引，注意<code>CFBundleDisplayName</code>前后没有引号，这个文件是专门用来本地化info.plist文件的。<br/>
<code><br/>
CFBundleDisplayName = &quot;你的软件名称&quot;;<br/>
NSLocationAlwaysUsageDescription = &quot;我需要使用手机的定位服务，请授权&quot;;<br/>
</code><br/>
<code>NSLocationAlwaysUsageDescription</code>键值则是位置服务授权时候的提示语。如此一来就实现了info.plist文件本地化，是不是很简单？</p>

<p>我们的本地化教学就告一段落了，有其他问题请留言哦。</p>

                        
                      </div>
                  </div>
                </a>
                <div class="read-more clearfix">
                  <div class="more-left left">
                  
                    <span class="date">2015/12/23</span>
                    <span>posted in&nbsp;</span> 
          				  
          					    <span class="posted-in"><a href='Note.html'>Note</a></span>
          				   
                  </div>
                  <div class="more-right right">
                  <span class="comments">
                      

                       
                  </span>
                  </div>
                </div>
              </div><!-- article -->
        
			<div class="article">
                <a class="clearlink" href="14506845151229.html">
                
                  <h1>iOS系统授权开发</h1>
                  <div class="a-content">
                      
                      <div class="a-content-text">
                        
                        	<p>iOS系统开发中，最常用的系统授权，莫过于<code>系统通知</code>,<code>用户相册</code>,<code>位置服务</code>了，这篇文章将简单讲解这三项功能的开发，并附带我写的一个<a href="https://github.com/zsy78191/DeviceAccessViewController">开源项目</a>，统一管理系统授权。</p>

<p>注：本文和项目基于<code>iOS 8.0</code>及以上系统框架，低版本框架接口略有不同。</p>

<p><img src="/img/bVrGHs" alt="截图"/></p>

<h2 id="toc_0">系统通知授权</h2>

<p>系统通知方法在UIApplication类方法中，其中使用<code>isRegisteredForRemoteNotifications</code>获取本地推送授权状态。</p>

<pre><code>+ (UIUserNotificationType)notificationType
{
    UIApplication* application = [UIApplication sharedApplication];
    return  [application currentUserNotificationSettings].types;
}
</code></pre>

<p>这里授权状态的枚举类型有<br/>
1. <code>UIUserNotificationTypeNone</code> 无授权<br/>
2. <code>UIUserNotificationTypeBadge</code> 角标<br/>
3. <code>UIUserNotificationTypeSound</code> 声音<br/>
4. <code>UIUserNotificationTypeAlert</code> 通知</p>

<p>原枚举如下<br/>
<code><br/>
typedef NS_OPTIONS(NSUInteger, UIUserNotificationType) {<br/>
    UIUserNotificationTypeNone    = 0,      // the application may not present any UI upon a notification being received<br/>
    UIUserNotificationTypeBadge   = 1 &lt;&lt; 0, // the application may badge its icon upon a notification being received<br/>
    UIUserNotificationTypeSound   = 1 &lt;&lt; 1, // the application may play a sound upon a notification being received<br/>
    UIUserNotificationTypeAlert   = 1 &lt;&lt; 2, // the application may display an alert upon a notification being received<br/>
} NS_ENUM_AVAILABLE_IOS(8_0) __TVOS_PROHIBITED;<br/>
</code></p>

<p>授权方法<br/>
<code><br/>
UIUserNotificationType type = UIUserNotificationTypeBadge | UIUserNotificationTypeAlert | UIUserNotificationTypeSound;<br/>
UIUserNotificationSettings *setting = [UIUserNotificationSettings settingsForTypes:type categories:nil];<br/>
[[UIApplication sharedApplication] registerUserNotificationSettings:setting];<br/>
</code></p>

<p>注意，每一项授权，一旦用户拒绝，必须前往<code>设置</code>的相关APP页面开启。APP内跳<code>设置</code>的方法是</p>

<pre><code>[[UIApplication sharedApplication] openURL:[NSURL URLWithString:UIApplicationOpenSettingsURLString]];
</code></pre>

<p>注册本地通知也是有回调的，实现<code>UIApplicationDelegate</code>的<code>didRegisterUserNotificationSettings</code>方法。<br/>
```<br/>
- (void)application:(UIApplication *)application didRegisterUserNotificationSettings:(UIUserNotificationSettings *)notificationSettings<br/>
{</p>

<p>}<br/>
```</p>

<p>相应的也有失败的回调。</p>

<h2 id="toc_1">系统相册授权</h2>

<p>8.0系统版本以后，框架中加入了<code>Photos.framework</code>框架，当然是用<code>UIImagePickerController</code>同样会提醒用户授权使用相册或相机，这里介绍一下<code>Photos</code>框架的授权。</p>

<p>相册权限状态<br/>
<code><br/>
+ (PHAuthorizationStatus)photoAccesStatus<br/>
{<br/>
    return [PHPhotoLibrary authorizationStatus];<br/>
}<br/>
</code></p>

<pre><code>typedef NS_ENUM(NSInteger, PHAuthorizationStatus) {
    PHAuthorizationStatusNotDetermined = 0, // User has not yet made a choice with regards to this application
    PHAuthorizationStatusRestricted,        // This application is not authorized to access photo data.
                                            // The user cannot change this application’s status, possibly due to active restrictions
                                            //   such as parental controls being in place.
    PHAuthorizationStatusDenied,            // User has explicitly denied this application access to photos data.
    PHAuthorizationStatusAuthorized         // User has authorized this application to access photos data.
} NS_AVAILABLE_IOS(8_0);
</code></pre>

<p>这里授权状态有四个状态<br/>
1. <code>PHAuthorizationStatusNotDetermined</code> 未授权<br/>
2. <code>PHAuthorizationStatusRestricted</code> 授权中<br/>
3. <code>PHAuthorizationStatusDenied</code> 拒绝<br/>
4. <code>PHAuthorizationStatusAuthorized</code> 已授权</p>

<p>授权Block方法<br/>
```<br/>
 [PHPhotoLibrary requestAuthorization:<sup>PHAuthorizationStatus status</sup> {</p>

<p>}];<br/>
```</p>

<h2 id="toc_2">位置服务授权</h2>

<p>位置服务授权稍微复杂一点点，8.0以后，进行位置服务授权要注意一点是，需要在工程的<code>Info.plist</code>文件中加入<code>NSLocationAlwaysUsageDescription</code>字段。字段中是开发者展示给用户的位置服务的使用场景介绍，或者是请求授权的描述。如果不添加这个字段，授权接口无任何反应。</p>

<p>状态接口<br/>
<code><br/>
+ (CLAuthorizationStatus)positionAuthorizationStatus<br/>
{<br/>
    return [CLLocationManager authorizationStatus];<br/>
}<br/>
</code></p>

<p>授权方法<br/>
<code><br/>
+ (void)authorizedPosition:(CLLocationManager *)manager<br/>
{<br/>
    [manager requestAlwaysAuthorization];<br/>
}<br/>
</code></p>

<p>注意这里传入的manager一定要是个<code>property</code>,如果是一个局部变量，大括号结束，释放掉了，授权就会消失，就会出现授权框一闪而过的现象。</p>

<p><a href="https://github.com/zsy78191/DeviceAccessViewController">开源项目 DeviceAccessViewController</a></p>

                        
                      </div>
                  </div>
                </a>
                <div class="read-more clearfix">
                  <div class="more-left left">
                  
                    <span class="date">2015/12/21</span>
                    <span>posted in&nbsp;</span> 
          				  
          					    <span class="posted-in"><a href='Note.html'>Note</a></span>
          				   
                  </div>
                  <div class="more-right right">
                  <span class="comments">
                      

                       
                  </span>
                  </div>
                </div>
              </div><!-- article -->
        
			<div class="article">
                <a class="clearlink" href="14515485158287.html">
                
                  <h1>iOS自定义控件教程（一）看看吧，总会得到你想要的</h1>
                  <div class="a-content">
                      
                      <div class="a-content-text">
                        
                        	<h2 id="toc_0">简介</h2>

<p>本文将是一个关于Cocoa Touch中UIKit框架的自定义控件系列教程，我们将从基础开始，由浅入深，分析讲解自定义控件的相关知识和技巧。</p>

<h2 id="toc_1">基础概念，给新人看</h2>

<h3 id="toc_2">基础知识</h3>

<ol>
<li><code>UIKit</code>是<code>iOS</code>系统使用的界面框架</li>
<li><code>UIKit</code>中最基本的类是<code>UIView</code>，也就是界面的基础操作类</li>
<li>iOS使用的渲染框架叫<code>Core Graphics</code>，所以才回有<code>CG</code>开头的一堆基础类型，如CGFloat(浮点),CGPoint(点),CGSize(尺寸),CGRect(矩形)</li>
<li><code>UIView</code>对象都包含至少一个<code>CALayer</code>对象，<code>CALayer</code>才是最终渲染出效果的对象</li>
<li><code>UIView</code>和<code>CALayer</code>的层级关系是相同的，他们都是多叉树，同一个<code>父View(superView)</code>的<code>子View们（subViews）</code>是有层级覆盖关系的，上层的View遮挡下层View</li>
<li>这里所说的<code>层</code>关系和设计软件中的层关系是类似的，如Photoshop，Sketch等</li>
<li><code>UIView</code>和<code>CALayer</code>的分工是，前者负责<strong>保存属性</strong>和<strong>处理响应链</strong>，后者负责渲染</li>
</ol>

<h2 id="toc_3">一、 UIView的基本属性和方法</h2>

<p>今天我们一起做一个多段选择的自定义控件，顺便学习UIView的基本属性和方法。先来看一下实现的效果：<a href="https://github.com/zsy78191/XXXSegmentView">Github下载源码</a></p>

<p><img src="/img/bVrUXW" alt="图片描述"/></p>

<p>我们的多段选择View，暂且命名为XXXSegmentView，继承自<code>UIView</code>。首先创建一个新文件，选择xcode菜单，File －&gt; New -&gt; File </p>

<p><img src="/img/bVrUYg" alt="图片描述"/><br/>
<img src="/img/bVrUYh" alt="图片描述"/></p>

<p>得到文件<code>XXXSegmentView.h</code>和<code>XXXSegmentView.m</code>，我们给<code>XXXSegmentView</code>写一个初始化配置的方法，<code>- (void)configForTitles:(NSArray&lt;NSString*&gt;*)titles;</code>。</p>

<pre><code>@interface XXXSegmentView : UIView
 
- (void)configForTitles:(NSArray&lt;NSString*&gt;*)titles;
@property (nonatomic, assign) NSInteger number; //记录titles的个数
@end
</code></pre>

<p>这里注明了要使用者传入一个包含字符串类型的数组。这样我们的自定义控件之要两步就能初始化完毕，如下在ViewController中加入初始化代码:</p>

<pre><code>- (void)configSegment
{
    XXXSegmentView* segment = [[XXXSegmentView alloc] initWithFrame:CGRect(0,0,300,80)];
    
    //加入三个标题，内容入数组中传入
    [segment configForTitles:@[@&quot;Main&quot;,@&quot;More&quot;,@&quot;Me&quot;]];
    
    [self.view addSubview:segment];
}
</code></pre>

<p><strong>解释:CGRect(0,0,300,80)返回一个CGRect数据，是一个矩形，前两个值是起始点，也就是左上角的坐标，后两个数是尺寸，300是宽，80是高</strong></p>

<p>接下来我们需要实现<code>configForTitles</code>这个方法了。来到<code>XXXSegmentView</code>中，我们加入代码:</p>

<pre><code>- (void)cleanAll
{
    [self.subviews enumerateObjectsUsingBlock:^(id obj, NSUInteger idx, BOOL *stop) {
        if ([obj isKindOfClass:[UILabel class]]) {
             [obj removeFromSuperview];
        }
    }];
}
</code></pre>

<p><strong>解释:cleanAll这个方法，通过self.subviews方法，返回的是包含了segmentView的全部子view的数组，然后用enumerateObjectsUsingBlock方法进行快速枚举，筛选出其中是UILabel的View，调用它的removeFromSuperview方法将其移除</strong></p>

<p>这个函数存在的意义，就是在使用者多次调用<code>configForTitles</code>更改标签的时候，清除掉旧的Label。</p>

<pre><code>- (UILabel*)standLabel
{
    UILabel * label = [[UILabel alloc] initWithFrame:CGRectMake(0, 0, 100, 50)];
    label.font = [UIFont systemFontOfSize:14];
    label.textColor = self.tintColor;
    return label;
}
</code></pre>

<p><strong>解释：UILabel类是UIView的子类，用于显示文字，支持多行显示，支持改变字体和颜色</strong><br/>
<strong>[UIFont systemFontOfSize:14]方法返回一个系统字体对象UIFont</strong><br/>
<strong>label.textColor = self.tintColor;这一步将我们segment的tintColor传给了Label作为字体Color</strong></p>

<p>所谓的<code>TintColor</code>可以理解为控件的高亮颜色，是UIView的默认属性，所以继承于UIView的XXXSegmentView也有这个属性，并且有默认值。</p>

<pre><code>- (void)configForTitles:(NSArray *)titles
{
    [self cleanAll];
     self.number = titles.count;
    [titles enumerateObjectsUsingBlock:^(id obj, NSUInteger idx, BOOL *stop) {
        UILabel* la = [self standLabel];
        [la setText:obj];
        [la setBackgroundColor:[UIColor clearColor]];
        [self addSubview:la];
        la.tag = idx + 981;
    }];
}
</code></pre>

<p><strong>解释</strong>我们首先记录了标题的个数，然后调用<code>cleanAll</code>方法，清楚旧的Label，然后根据传入的titles数组，给View加入新的Label，并且，我们给label加了文字，和透明色<code>([UIColor clearColor])</code>的背景。</p>

<p>最后我们给每一个Label加了一个<code>Tag</code>编号，这个编号从981（这个数是我随便选的，你也可以选个更大的）开始，用来标记我们的Label们前后顺序。</p>

<h3 id="toc_4">布局入门</h3>

<p>代码写到这里，我们运行软件，并不能得到想要的并排展示效果，因为我们所有的label，位置没有做调整。</p>

<p>用什么属性控制UIView的位置呢？答案是<code>Frame</code>属性。 </p>

<p>我们把屏幕比作一个画板，左上角是(0,0)坐标，frame则是一个矩形，如CGRect(0,0,100,50)代表一个从(0,0)点开始，宽100，高50的矩形。当我们重新设置UIView的Frame属性，他们的位置就改变了。</p>

<p>所以我们给XXXSegmentView.m加入如下代码:</p>

<pre><code>- (CGRect)boundsWithLabel:(UILabel*)label
{
    return [label.text boundingRectWithSize:CGSizeMake(CGFLOAT_MAX, label.frame.size.height) options:NSStringDrawingUsesFontLeading attributes:@{NSFontAttributeName:label.font} context:nil];
}

</code></pre>

<p>这个方法用来返回一个字符串渲染出来的边界，<code>boundingRectWithSize:CGSizeMake</code>这个方法比较复杂，初学者看不懂直接粘过来用下就行，这里不需要理解。<br/>
不过我还是要解释一下，这个方法传入的第一个CGSize是，外包围的限制，CGFLOAT_MAX返回的是最大的浮点数，也就是这里在计算宽度时不做限制。NSStringDrawingUsesFontLeading属性表示用自字体作为计算行高的标准，attributes字典传入的是文字的渲染样式，NSFontAttributeName键传入文字的字体和字号，返回的CGRect是文字根据以上要求，渲染出来的外包围。</p>

<pre><code>- (void)layoutSubviews
{
    [super layoutSubviews];

    [self.subviews enumerateObjectsUsingBlock:^(id obj, NSUInteger idx, BOOL *stop) {
        if ([obj isKindOfClass:[UILabel class]]) {
            UILabel* label = obj;
            CGRect rect = [self boundsWithLabel:label];
            [label setFrame:CGRectMake(0, 0, rect.size.width, rect.size.height)];
            label.center = CGPointMake(self.frame.size.width/(self.number*2)*((label.tag-981)*2+1), self.frame.size.height/2);
        }
    }];
}
</code></pre>

<p><strong>解释</strong><code>layoutSubviews</code>方法是UIView的固有方法，这个方法在我们View需要给子View布局的时候会自动调用，我们重写了这个方法，所以要用<code>super</code>指针，先调用父类方法｀[super layoutSubviews];｀，虽然UIView的layoutSubviews方法很有可能是空的，但这是好习惯。</p>

<p>然后我们又通过subviews数组快速遍历子View，筛选出UILabel对象，因为我们的子View中以后要加入其它不是UILabel的对象。遍历过程中我们改变Label的外包围，通过上面说的计算外包围的接口，然后通过<code>center(中心点)</code>这个<code>UIView</code>的属性来改变子Label的位置。label.tag-981是Label的序号，self.frame.size.width是我们SegmentView的宽度，self.number是label的个数。</p>

<p>然后我们再运行程序，是不是完成了Label的布局啦，并不复杂，下一篇我们将继续讲解。</p>

                        
                      </div>
                  </div>
                </a>
                <div class="read-more clearfix">
                  <div class="more-left left">
                  
                    <span class="date">2015/12/31</span>
                    <span>posted in&nbsp;</span> 
          				  
          					    <span class="posted-in"><a href='%E5%8F%82%E8%80%83.html'>参考</a></span>
          				   
                  </div>
                  <div class="more-right right">
                  <span class="comments">
                      

                       
                  </span>
                  </div>
                </div>
              </div><!-- article -->
        
			<div class="article">
                <a class="clearlink" href="14503342491175.html">
                
                  <h1>iOS设备授权全解析</h1>
                  <div class="a-content">
                      
                      <div class="a-content-text">
                        
                        	<h2 id="toc_0">通知</h2>

<pre><code>@interface UIApplication (UIRemoteNotifications)

// Calling this will result in either application:didRegisterForRemoteNotificationsWithDeviceToken: or application:didFailToRegisterForRemoteNotificationsWithError: to be called on the application delegate. Note: these callbacks will be made only if the application has successfully registered for user notifications with registerUserNotificationSettings:, or if it is enabled for Background App Refresh.

- (void)registerForRemoteNotifications NS_AVAILABLE_IOS(8_0);

- (void)unregisterForRemoteNotifications NS_AVAILABLE_IOS(3_0);

// Returns YES if the application is currently registered for remote notifications, taking into account any systemwide settings; doesn&#39;t relate to connectivity.
- (BOOL)isRegisteredForRemoteNotifications NS_AVAILABLE_IOS(8_0);

- (void)registerForRemoteNotificationTypes:(UIRemoteNotificationType)types NS_DEPRECATED_IOS(3_0, 8_0, &quot;Please use registerForRemoteNotifications and registerUserNotificationSettings: instead&quot;) __TVOS_PROHIBITED;

// Returns the enabled types, also taking into account any systemwide settings; doesn&#39;t relate to connectivity.
- (UIRemoteNotificationType)enabledRemoteNotificationTypes NS_DEPRECATED_IOS(3_0, 8_0, &quot;Please use -[UIApplication isRegisteredForRemoteNotifications], or -[UIApplication currentUserNotificationSettings] to retrieve user-enabled remote notification and user notification settings&quot;) __TVOS_PROHIBITED;

@end
</code></pre>

                        
                      </div>
                  </div>
                </a>
                <div class="read-more clearfix">
                  <div class="more-left left">
                  
                    <span class="date">2015/12/17</span>
                    <span>posted in&nbsp;</span> 
          				  
          					    <span class="posted-in"><a href='Note.html'>Note</a></span>
          				   
                  </div>
                  <div class="more-right right">
                  <span class="comments">
                      

                       
                  </span>
                  </div>
                </div>
              </div><!-- article -->
        
			<div class="article">
                <a class="clearlink" href="14513778158453.html">
                
                  <h1>opencv 学习笔记</h1>
                  <div class="a-content">
                      
                      <div class="a-content-text">
                        
                        	<p>Mat() 构造函数</p>

<pre><code>cv::Mat mat(2,2, CV_8UC3, cv::Scalar(0,0,255));
</code></pre>

<p>为已存在IplImage指针创建信息头:</p>

<pre><code>IplImage* img = cvLoadImage(&quot;greatwave.png&quot;, 1);
Mat mtx(img); // convert IplImage* -&gt; Mat
</code></pre>

<p>Create() function: 函数，这个创建方法不能为矩阵设初值，它只是在改变尺寸时重新为矩阵数据开辟内存。</p>

<pre><code>M.create(4,4, CV_8UC(2));
cout &lt;&lt; &quot;M = &quot;&lt;&lt; endl &lt;&lt; &quot; &quot;  &lt;&lt; M &lt;&lt; endl &lt;&lt; endl;
</code></pre>

                        
                      </div>
                  </div>
                </a>
                <div class="read-more clearfix">
                  <div class="more-left left">
                  
                    <span class="date">2015/12/29</span>
                    <span>posted in&nbsp;</span> 
          				  
          					    <span class="posted-in"><a href='Note.html'>Note</a></span>
          				   
                  </div>
                  <div class="more-right right">
                  <span class="comments">
                      

                       
                  </span>
                  </div>
                </div>
              </div><!-- article -->
        
			<div class="article">
                <a class="clearlink" href="14531702672213.html">
                
                  <h1>password</h1>
                  <div class="a-content">
                      
                      <div class="a-content-text">
                        
                        	<p>在基础加密技术上，Dashlane 同样采用的是世界领先的 AES-256 加密标准，以及超过上万次的 PBKDF2 密钥拉伸，不过这些都是一个合格的密码管理工具所需要具备的基本素质，Dashlane 所带来的 New Feature 中有一点很重要 —— Password Changer。</p>

                        
                      </div>
                  </div>
                </a>
                <div class="read-more clearfix">
                  <div class="more-left left">
                  
                    <span class="date">2016/1/19</span>
                    <span>posted in&nbsp;</span> 
          				  
          					    <span class="posted-in"><a href='%E5%8F%82%E8%80%83.html'>参考</a></span>
          				   
                  </div>
                  <div class="more-right right">
                  <span class="comments">
                      

                       
                  </span>
                  </div>
                </div>
              </div><!-- article -->
        
			<div class="article">
                <a class="clearlink" href="14558478337548.html">
                
                  <h1>http://api.aigolife.com/wristband/UpdateUserExtInfo.json?username=15737935935&extInfo=%7b%22childPhoneNum%22%3a%2215737935935%22%7d</h1>
                  <div class="a-content">
                      
                      <div class="a-content-text">
                        
                        	<p>&amp;token=62b00f974b8003de7cdac4a6c7ddee17145584689945</p>

                        
                      </div>
                  </div>
                </a>
                <div class="read-more clearfix">
                  <div class="more-left left">
                  
                    <span class="date">2016/2/19</span>
                    <span>posted in&nbsp;</span> 
          				  
          					    <span class="posted-in"><a href='%E5%8F%82%E8%80%83.html'>参考</a></span>
          				   
                  </div>
                  <div class="more-right right">
                  <span class="comments">
                      

                       
                  </span>
                  </div>
                </div>
              </div><!-- article -->
        
			<div class="article">
                <a class="clearlink" href="14500612061322.html">
                
                  <h1>一日一写</h1>
                  <div class="a-content">
                      
                      <div class="a-content-text">
                        
                        	<p>2015/12/14 <a href="http://www.jianshu.com/p/158fda162794">SwizzleMethod的黑魔法</a></p>

<p>2015/12/15 <a href="http://segmentfault.com/a/1190000004153558">CloudKit入门</a></p>

<p>2015/12/16 <a href="http://segmentfault.com/a/1190000004155857">iOS后台模式教程 （一）</a></p>

<p>2015/12/17 <a href="https://github.com/zsy78191/DeviceAccessViewController">Github项目 DeviceAccessViewController</a></p>

<p>2015/12/21 <a href="http://segmentfault.com/a/1190000004176855">iOS系统授权开发</a> </p>

<p>2015/12/22 <a href="http://segmentfault.com/a/1190000004182437">iOS 本地化开发入门</a></p>

<p>2015/12/22 <a href="https://github.com/zsy78191/SimpleLocalizedTool">Github项目 SimpleLocalizedTool开源工具</a></p>

<p>2015/12/23 <a href="http://segmentfault.com/a/1190000004187941">iOS 本地化进阶教程</a></p>

<p>2015/12/24 <a href="http://segmentfault.com/a/1190000004192662">UITableView 编辑模式详解</a></p>

<p>2015/12/25 <a href="https://github.com/zsy78191/DEFetchRC">Github项目 DEFetchRC</a></p>

<p>2015/12/25 <a href="http://segmentfault.com/a/1190000004201188">NSFetchedResultsController的简单封装 － UITableView与CoreData的完美结合</a></p>

                        
                      </div>
                  </div>
                </a>
                <div class="read-more clearfix">
                  <div class="more-left left">
                  
                    <span class="date">2015/12/14</span>
                    <span>posted in&nbsp;</span> 
          				  
          					    <span class="posted-in"><a href='Note.html'>Note</a></span>
          				   
                  </div>
                  <div class="more-right right">
                  <span class="comments">
                      

                       
                  </span>
                  </div>
                </div>
              </div><!-- article -->
        
			<div class="article">
                <a class="clearlink" href="14500611755539.html">
                
                  <h1>一日一读</h1>
                  <div class="a-content">
                      
                      <div class="a-content-text">
                        
                        	<p>2015/12/14  <a href="http://blog.sunnyxx.com/tags/iOS9/">2015 Objective-C 新特性 Nullability Lightweight Generics  自定义泛型类</a>  </p>

<p>2015/12/15 <a href="http://nshipster.cn/cloudkit/">Cloud​Kit</a></p>

<p>2015/12/16 <a href="http://www.raywenderlich.com/92428/background-modes-ios-swift-tutorial">Background Modes Tutorial: Getting Started</a></p>

<p>2015/12/17 <a href="http://www.cocoachina.com/ios/20151217/14707.html">iOS：你App的设置做对了吗</a></p>

<p>2015/12/24 Effective Objective-C 2.0 一书</p>

                        
                      </div>
                  </div>
                </a>
                <div class="read-more clearfix">
                  <div class="more-left left">
                  
                    <span class="date">2015/12/14</span>
                    <span>posted in&nbsp;</span> 
          				  
          					    <span class="posted-in"><a href='Note.html'>Note</a></span>
          				   
                  </div>
                  <div class="more-right right">
                  <span class="comments">
                      

                       
                  </span>
                  </div>
                </div>
              </div><!-- article -->
        
			<div class="article">
                <a class="clearlink" href="14531917200883.html">
                
                  <h1>主板 800        华硕 650</h1>
                  <div class="a-content">
                      
                      <div class="a-content-text">
                        
                        	<p>内存 300<br/>
电源 400<br/>
散热器 200<br/>
机箱 200<br/>
键盘 100<br/>
鼠标 100<br/>
音响 200<br/>
CPU 1300      AMD FX 8350     1200  或者 FX 6300 640     fx 8300  850<br/>
显卡  1650     ATI R9 370x        1200<br/>
机械硬盘 300<br/>
固态硬盘 400<br/>
显示器 800</p>

<p>一共 6750</p>

<p>四川省宜宾市南溪区罗龙街道办达信电脑</p>

<p>13608292511 郭敏</p>

<p>2900<br/>
4000<br/>
2700<br/>
4000<br/>
2800<br/>
9000<br/>
30000<br/>
1200</p>

<ol>
<li>谁最有可能以后奉子成婚</li>
<li>谁最有可能以后转变为双性恋</li>
<li>谁最有可能在旅途上遇见一个炮友然后发展为恋人最终把他劈腿了</li>
<li>谁最有可能跳河自杀，但嫌河脏又爬上来</li>
<li>谁最有可能开枪自杀，中弹十八发而没死，于是自己开车去找医生</li>
<li>谁最有可能入室盗窃，误将鞭炮当蜡烛，被炸成重伤</li>
<li>谁最有可能把一百元人民币换成硬币，存一百次</li>
<li>谁最有可能花20万人民币造出17万假币</li>
<li>谁最有可能在举枪自杀时，警察为防止该他自杀，将其击毙</li>
<li>谁最有可能因造谣自己因造谣而被拘留15天而被拘留15天</li>
<li>谁最有可能去宾馆开房叫两个小姐打斗地主，倒赢小姐2000多</li>
<li>谁最有可能入室盗窃时，因怕有脚步声，脱下鞋子，脚太臭熏醒屋主</li>
<li>谁最有可能发现伴侣出轨，连捅32刀，刀刀避开要害</li>
<li>谁最有可能为了抢别人可乐，不惜向可乐里吐痰</li>
<li>谁最有可能成为一名僧人</li>
<li>谁最有可能成为一位性瘾患者</li>
</ol>

<p>3 2 1<br/>
喝一杯啤酒 退出本轮<br/>
押注 写名字 押对了 减三分， 押错了 喝一杯<br/>
最后按积分，123名 321杯</p>

<p>谁是卧底</p>

<p>微软 &amp;&amp; 苹果<br/>
安卓 &amp;&amp; iOS<br/>
鼠标 &amp;&amp; 键盘<br/>
小矮人 &amp;&amp; 葫芦娃<br/>
郭德纲 &amp;&amp; 岳云鹏<br/>
梁山伯 &amp;&amp; 罗密欧<br/>
首尔 &amp;&amp; 东京<br/>
安倍晋三 &amp;&amp; 狗<br/>
李昊 &amp;&amp; 张弛<br/>
魔兽世界 &amp;&amp; 英雄联盟 <br/>
小米 &amp;&amp; 锤子<br/>
IE &amp;&amp; 火狐<br/>
家乐福 &amp;&amp; 沃尔玛<br/>
女演员 &amp;&amp; AV女优<br/>
优酷土豆 &amp;&amp; 爱奇艺<br/>
香港 &amp;&amp; 澳门<br/>
冈本 &amp;&amp; 杜蕾斯</p>

                        
                      </div>
                  </div>
                </a>
                <div class="read-more clearfix">
                  <div class="more-left left">
                  
                    <span class="date">2016/1/19</span>
                    <span>posted in&nbsp;</span> 
          				  
          					    <span class="posted-in"><a href='%E5%8F%82%E8%80%83.html'>参考</a></span>
          				   
                  </div>
                  <div class="more-right right">
                  <span class="comments">
                      

                       
                  </span>
                  </div>
                </div>
              </div><!-- article -->
        
			<div class="article">
                <a class="clearlink" href="14557724301128.html">
                
                  <h1>佳</h1>
                  <div class="a-content">
                      
                      <div class="a-content-text">
                        
                        	<p>我知道我上午说话有些过分，给了你十万付特的打击，对不起。</p>

<p>我并没有恶意，我也没有抱怨你，只是觉得不是那么快乐。</p>

<p>上一次你那么不懂礼貌，在那群朋友那里留下了坏名声，我尽力去挽回，但又被挂上了“被看得紧”的名号，是不是就有人在群里嘲讽我一句，我却无从还口。</p>

<p>我今天之所以这么生气，归根结底还是因为你不愿意跟我沟通，不愿意接我电话。</p>

<p>我在两个小时中，拨了60多通电话，心里真的很不舒服。</p>

<p>你也可以认为我这么做是自己作，但我真的很难受，我想在电话里把话跟你说清楚，我喜欢用QQ微信短信。</p>

<p>你也知道的，我们认识这几年，你要做的事我基本没有拦过你。我要做的事，你基本都拦下了，即使没拦下，也会憋一肚子火，一肚子怨气。</p>

<p>他们说两个人相爱，什么叫爱，就是你跟他（她）在一起，变得越来越好。的确，你让我改变了很多，我很感谢。同时向你表示抱歉，因为我没有让你变的更好。</p>

<p>我无意冒犯你的性格，你的脾气，我觉得我唯一能帮你的事，就是帮你找到自己喜欢做的事，帮你找到人生的追求。但结果并不理想，是我的失职。</p>

<p>晚上回矿大吧，我在家等你，回来我给你做好吃的手擀面。屋子还要收拾，有话我们好好说，好吗？</p>

                        
                      </div>
                  </div>
                </a>
                <div class="read-more clearfix">
                  <div class="more-left left">
                  
                    <span class="date">2016/2/18</span>
                    <span>posted in&nbsp;</span> 
          				  
          					    <span class="posted-in"><a href='%E5%8F%82%E8%80%83.html'>参考</a></span>
          				   
                  </div>
                  <div class="more-right right">
                  <span class="comments">
                      

                       
                  </span>
                  </div>
                </div>
              </div><!-- article -->
        
			<div class="article">
                <a class="clearlink" href="14531821384029.html">
                
                  <h1>游戏剧本</h1>
                  <div class="a-content">
                      
                      <div class="a-content-text">
                        
                        	<h2 id="toc_0">核心玩法</h2>

<p>非手残游戏，娱乐玩法。玩家扮演的角色，贯穿一段主线剧情，并根据不同的玩法，得到不同结局。<br/>
两个角色，一男一女<br/>
两个职业方向，铸造师和药剂师</p>

<h2 id="toc_1">世界观</h2>

<p>架空历史和平行世界世界观，时空穿梭世界观</p>

<h2 id="toc_2">剧情走向</h2>

<h3 id="toc_3">开始</h3>

<p>玩家是现实世界的一个普通人，是一个中学生。</p>

<p>某天玩家在路上捡了一块宿敌欺负，争斗中宿敌</p>

                        
                      </div>
                  </div>
                </a>
                <div class="read-more clearfix">
                  <div class="more-left left">
                  
                    <span class="date">2016/1/19</span>
                    <span>posted in&nbsp;</span> 
          				  
          					    <span class="posted-in"><a href='%E5%8F%82%E8%80%83.html'>参考</a></span>
          				   
                  </div>
                  <div class="more-right right">
                  <span class="comments">
                      

                       
                  </span>
                  </div>
                </div>
              </div><!-- article -->
        
			<div class="article">
                <a class="clearlink" href="14514470638588.html">
                
                  <h1>程序员的理想主义</h1>
                  <div class="a-content">
                      
                      <div class="a-content-text">
                        
                        	<p>我是一个程序员，也是一个理想主义者。</p>

<p>作为一个五年多的从业者，我回想起当初跨入这一行的初衷，是因为这里是理想主义者的净土。</p>

<p>2011年iPhone蓄势待发准备横扫全球，App Store开始造富，让我们这些非计算机专业的穷学生，都开始转入App行业酌一杯羹。App Store给了全球的开发者一个平台，在这个平台上，人人平等，你不用贿赂巴结苹果的工作人员，也可以常年在榜单上占据一席之地，只要你的软件，足够好。</p>

<p>后来走入社会的我，靠着自学的技术，在北京的一家IT公司找了一份不错的工作。毕竟不是科班出身，敬畏心很强的我从工作后一直不敢放松，一直学到今天还在不断学习新的知识。因为在程序员这一行，归根结底看的还是工作能力。也许你内向、沉默寡言，也许你人缘超好、很会维系同事关系，也许你脾气很坏，经常跟产品经理吵架，注意，这都无所谓，只要你的技术是公司无法替代的，公司不会亏待你。</p>

<p>虽然现实情况并没有我说的这么好，比如在我的老东家工作，程序员还是没有商务部门的人强势，甚至会被HR部门压一头，单相对于其它行业，已经强很多了吧，反正我没干过拿报纸、端茶倒水这些伺候人的活。</p>

<p>工作几年后，大部分人都会面临一个现实问题，“要不要转做管理？”</p>

<p>我反正是这么想的，不做管理前，我向技术总监或者部门经理汇报，做管理吧，我就成了汇报中枢了。和人打交道这件事，还是挺复杂的、挺耗时的，我还是省省时间改进代码吧。但毕竟每个人有自己不同的追求，我觉得有能力和爱好的人还是应该尝试管理口的，毕竟管理口的晋升路更宽，有更大的权力，才能做更大的事。像我这种喜欢新事物、喜欢开源、喜欢分享技术的程序员，还是继续搞技术才能让我内心踏实。</p>

<p>虽然我是理想主义程序员，但我也是物质的，只是我对单纯的物质没有兴趣罢了。这要怎么理解呢？我举几个例子：比如我会希望自己的App大卖，挣很多钱，但我不会去买彩票，虽然概率差不多（哈哈哈），因为对我来说，大卖的意义要高于挣了很多钱，我更希望去做点什么事，然后顺便挣了点钱糊口。</p>

<p>再比如我也想写技术书籍，把我积累的经验和知识分享给初学者，顺便挣点钱糊口（理想要和物质结合），但我不会去做代购，虽然后者门槛更低挣的更多。因为我只是想做点事，不是单纯地想挣钱，当然代购的人也可以说他们想让国人用到国外的好商品，顺便挣点钱（哈哈哈）。</p>

<p>我挣的不多，但工作很开心，因为想把自己喜欢的事情变成工作，真的很难。接着我又遇到一个问题，“你写代码能写多久？”</p>

<p>好沉重的一个话题，我也看过其他文章中说国外50多岁的老技术，两天可以完成普通程序员两周才能完成的工作；也看到过国外某些技术公司对待老技术这么好那么好的文章，但是，注意但是，我们毕竟不在国外。</p>

<p>不在国外我们能写一辈子代码么？我还年轻我无法回答，国内可能还没有在民企做这行，且在这行退休的前辈吧。所以我要立个flag，如果我退休时候还在写代码，我会回来告诉你们答案的。</p>

                        
                      </div>
                  </div>
                </a>
                <div class="read-more clearfix">
                  <div class="more-left left">
                  
                    <span class="date">2015/12/30</span>
                    <span>posted in&nbsp;</span> 
          				  
          					    <span class="posted-in"><a href='%E5%8F%82%E8%80%83.html'>参考</a></span>
          				   
                  </div>
                  <div class="more-right right">
                  <span class="comments">
                      

                       
                  </span>
                  </div>
                </div>
              </div><!-- article -->
        
			<div class="article">
                <a class="clearlink" href="14508363048700.html">
                
                  <h1>软件服务使用条款</h1>
                  <div class="a-content">
                      
                      <div class="a-content-text">
                        
                        	<p>感谢你使用<strong>{soft}</strong>软件及服务，你应当阅读并遵守《<strong>{soft}</strong>软件许可及服务协议》（以下简称“本协议”）的用户相关内容。若您对本声明的任何条款有异议，请停止使用<strong>{soft}</strong>所提供的全部服务。</p>

<h2 id="toc_0">个人隐私</h2>

<p>尊重用户个人隐私信息的私有性是<strong>{soft}</strong>的一贯原则，<strong>{soft}</strong>将通过技术手段、强化内部管理等办法充分保护用户的个人隐私信息，除法律或有法律赋予权限的政府部门要求或事先得到用户明确授权等原因外，<strong>{soft}</strong>保证不对外公开或向第三方透露用户个人隐私信息，或用户在使用服务时存储的非公开内容。</p>

<p>同时，为了运营和改善<strong>{soft}</strong>的技术与服务，<strong>{soft}</strong>将可能会自行收集使用或向第三方提供用户的非个人隐私信息，这将有助于<strong>{soft}</strong>向用户提供更好的用户体验和服务质量。</p>

<h2 id="toc_1">服务终止及暂停</h2>

<p>如用户滥用<strong>{soft}</strong>服务，利用<strong>{soft}</strong>平台发布广告或是垃圾信息，<strong>{soft}</strong>会行使暂停、收回、删除帐号的权利。</p>

                        
                      </div>
                  </div>
                </a>
                <div class="read-more clearfix">
                  <div class="more-left left">
                  
                    <span class="date">2015/12/23</span>
                    <span>posted in&nbsp;</span> 
          				  
          					    <span class="posted-in"><a href='Note.html'>Note</a></span>
          				   
                  </div>
                  <div class="more-right right">
                  <span class="comments">
                      

                       
                  </span>
                  </div>
                </div>
              </div><!-- article -->
        
              


			<div class="row">
			  <div class="large-6 columns">
			  <p class="text-left" style="padding-top:25px;">
			   
			  </p>
			  </div>
			  <div class="large-6 columns">
			<p class="text-right" style="padding-top:25px;">
			
			</p>
			  </div>
			</div>
		</div>
	</div><!-- large 8 -->

 <div class="large-4 medium-4 columns">
  <div class="hide-for-small">
    <div id="sidebar" class="sidebar">
          <div id="site-info" class="site-info">
            
                <h1>zsy78191</h1>
                <div class="site-des">个人博客</div>
                <div class="social">











  <a class="rss" href="atom.xml" title="RSS">RSS</a>
                
              	 </div>
          	</div>
              <div id="site-categories" class="side-item ">
                <div class="side-header">
                  <h2>Categories</h2>
                </div>
                <div class="side-content">

      	<p class="cat-list">
        
            <a href="%E5%8F%82%E8%80%83.html"><strong>参考</strong></a>
        
            <a href="Note.html"><strong>Note</strong></a>
         
        </p>


                </div>
              </div>

              <div id="site-categories" class="side-item">
                <div class="side-header">
                  <h2>Recent Posts</h2>
                </div>
                <div class="side-content">
                <ul class="posts-list">
	      
		      
			      <li class="post">
			        <a href="14543937535743.html"></a>
			      </li>
		     
		  
		      
			      <li class="post">
			        <a href="14531716978294.html">悦客接口需求</a>
			      </li>
		     
		  
		      
			      <li class="post">
			        <a href="14556955527053.html">1. 编辑地址接口，总是返回 ‘手机号填写有误哦’</a>
			      </li>
		     
		  
		      
			      <li class="post">
			        <a href="14502520092955.html">Background Modes Tutorial: Getting Started</a>
			      </li>
		     
		  
		      
			      <li class="post">
			        <a href="14561077487642.html">HTML</a>
			      </li>
		     
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		   
		  		</ul>
                </div>
              </div>
        </div><!-- sidebar -->
      </div><!-- hide for small -->
</div><!-- large 4 -->

</div><!-- row -->

 <div class="page-bottom clearfix">
  <div class="row">
   <p class="copyright">Copyright &copy; 2015
Powered by <a target="_blank" href="http://www.mweb.im">MWeb</a>,&nbsp; 
Theme used <a target="_blank" href="http://github.com">GitHub CSS</a>.</p>
  </div>
</div>

        </section>
      </div>
    </div>

  
    

    <script src="asset/js/foundation.min.js"></script>
    <script>
      $(document).foundation();
      function fixSidebarHeight(){
        var w1 = $('.markdown-body').height();
          var w2 = $('#sidebar').height();
          if (w1 > w2) { $('#sidebar').height(w1); };
      }
      $(function(){
        fixSidebarHeight();
      })
      $(window).load(function(){
          fixSidebarHeight();
      });
     
    </script>

    



  </body>
</html>
