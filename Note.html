<!doctype html>
<html class="no-js" lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>
    
  Note - zsy78191
  

  </title>
  <link href="atom.xml" rel="alternate" title="zsy78191" type="application/atom+xml">
    <link rel="stylesheet" href="asset/css/foundation.min.css" />
    <link rel="stylesheet" href="asset/css/docs.css" />
    <script src="asset/js/vendor/modernizr.js"></script>
    <script src="asset/js/vendor/jquery.js"></script>
  <script src="asset/highlightjs/highlight.pack.js"></script>
  <link href="asset/highlightjs/styles/github.css" media="screen, projection" rel="stylesheet" type="text/css">
  <script>hljs.initHighlightingOnLoad();</script>

  </head>
  <body class="antialiased hide-extras">
    
    <div class="marketing off-canvas-wrap" data-offcanvas>
      <div class="inner-wrap">


<nav class="top-bar docs-bar hide-for-small" data-topbar>


  <section class="top-bar-section">
  <div class="row">
      <div style="position: relative;width:100%;"><div style="position: absolute; width:100%;">
        <ul id="main-menu" class="left">
        <li id="menu_item_index"><a href="index.html">HOME</a></li>
        <li id="menu_item_archives"><a href="archives.html">Archives</a></li>
        <li id="menu_item_about"><a href="about.html">ABOUT</a></li>
        </ul>

        <ul class="right" id="search-wrap">
          <li>
<form target="_blank" action="http://google.com/search" method="get">
    <input type="hidden" name="q" value="site:" />
    <input tabindex="1" type="search" name="q"  placeholder="Search"/>
</form>
</li>
          </ul>
      </div></div>
  </div>
  </section>

</nav>

        <nav class="tab-bar show-for-small">
  <a href="javascript:void(0)" class="left-off-canvas-toggle menu-icon">
    <span> &nbsp; zsy78191</span>
  </a>
</nav>

<aside class="left-off-canvas-menu">
      <ul class="off-canvas-list">
       
       <li><a href="index.html">HOME</a></li>
    <li><a href="archives.html">Archives</a></li>
    <li><a href="about.html">ABOUT</a></li>

    <li><label>Categories</label></li>

        
            <li><a href="%E5%8F%82%E8%80%83.html">参考</a></li>
        
            <li><a href="Note.html">Note</a></li>
         

      </ul>
    </aside>

<a class="exit-off-canvas" href="#"></a>


        <section id="main-content" role="main" class="scroll-container">
 <script type="text/javascript">
	$(function(){
		$('#menu_item_index').addClass('is_active');
	});
</script>
<div class="row">
	<div class="large-8 medium-8 columns">
		<div class="markdown-body home-categories">
		
			<div class="article">
                <a class="clearlink" href="14502520092955.html">
                
                  <h1>Background Modes Tutorial: Getting Started</h1>
                  <div class="a-content">
                      
                      <div class="a-content-text">
                        
                        	<p>iOS后台模式教程 （一）</p>

<p><a href="http://www.raywenderlich.com/29948/backgrounding-for-ios">原文</a></p>

<h2 id="toc_0">使用场景</h2>

<p>在iOS7之前的系统中，当应用被挂起，拥有连续的10分钟时间来处理之前的任务，然后才会被系统终止。</p>

<p>所以，后台模式有一些特殊的使用场景。例如，更新位置，播放视频音频，和更新服务器请求。x</p>

<h2 id="toc_1">开始</h2>

<p>第一步设置工程中的<code>Capabilities</code>标签栏，打开<code>Background Modes</code>服务。</p>

<p>出现的<code>Modes</code>选项有</p>

<ul>
<li>Audio,AirPlay and Picture in Picture 视频音频播放</li>
<li>Location updates 位置更新</li>
<li>Voice over IP IP电话</li>
<li>Newsstand downloads 杂志下载</li>
<li>External accessory communication 外部附件通信，包括App Watch</li>
<li>Uses Bluetooth LE accessories 蓝牙LE配件</li>
<li>Acts as a Bluetooth LE accessory 作为蓝牙LE配件</li>
<li>Background fetch 后台抓取服务</li>
<li>Remote notifications 远程通知</li>
</ul>

<p>这里介绍几个模式的用法。</p>

<h2 id="toc_2">播放音频</h2>

<p>下面这段代码加入viewDidLoad中，程序开始时会按顺序播放两个mp3文件。在勾选<code>Audio,AirPlay and Picture in Picture</code>后，挂起程序时，音乐还是会继续播放 。</p>

<p>引用</p>

<pre><code>#import &lt;AVFoundation/AVFoundation.h&gt;
</code></pre>

<p>参数</p>

<pre><code>@property (nonatomic, strong) AVQueuePlayer *player;
</code></pre>

<p>viewDidLoad</p>

<pre><code> NSError *sessionError = nil;
    [[AVAudioSession sharedInstance] setCategory:AVAudioSessionCategoryPlayAndRecord error:&amp;sessionError];
    NSArray *queue = @[
                       [AVPlayerItem playerItemWithURL:[[NSBundle mainBundle] URLForResource:@&quot;music&quot; withExtension:@&quot;mp3&quot;]],
                        [AVPlayerItem playerItemWithURL:[[NSBundle mainBundle] URLForResource:@&quot;pop&quot; withExtension:@&quot;mp3&quot;]]];
    
self.player = [[AVQueuePlayer alloc] initWithItems:queue];
self.player.actionAtItemEnd = AVPlayerActionAtItemEndAdvance;
    
[self.player play];
</code></pre>

<h2 id="toc_3">位置服务</h2>

<p>参数</p>

<pre><code>@property (nonatomic, strong) CLLocationManager *locationManager;
@property (nonatomic, strong) NSMutableArray *locations;
</code></pre>

<p>初始化LocationManager</p>

<pre><code>self.locations = [[NSMutableArray alloc] init];
self.locationManager = [[CLLocationManager alloc] init];
self.locationManager.desiredAccuracy = kCLLocationAccuracyBest;
self.locationManager.delegate = self;
</code></pre>

<p>启动位置更新服务</p>

<pre><code>[self.locationManager startUpdatingLocation];
</code></pre>

<p>记录新位置</p>

<pre><code>- (void)locationManager:(CLLocationManager *)manager
    didUpdateToLocation:(CLLocation *)newLocation
           fromLocation:(CLLocation *)oldLocation
{
    // Add another annotation to the map. 
    if (UIApplication.sharedApplication.applicationState == UIApplicationStateActive)
    {
         //前台运行
    else
    {
        //后台运行
        NSLog(@&quot;App is backgrounded. New location is %@&quot;, newLocation);
    }
}
</code></pre>

<h3 id="toc_4">代码解析</h3>

<p>根据 <code>UIApplication.sharedApplication.applicationState == UIApplicationStateActive</code> 可以判断回调过程中，程序是否挂起。记住要勾选<code>Location updates</code>，当你在制作一个跑步或骑车软件时，需要用到这项功能。</p>

<h2 id="toc_5">一般性有限长度任务</h2>

<p>这个宽泛的功能包括上传或者下载任务等。</p>

<pre><code>@property (nonatomic) UIBackgroundTaskIdentifier backgroundTask;
</code></pre>

<pre><code>self.backgroundTask = [[UIApplication sharedApplication] beginBackgroundTaskWithExpirationHandler:^{
//        NSLog(@&quot;Background handler called. Not running background tasks anymore.&quot;);
        [[UIApplication sharedApplication] endBackgroundTask:self.backgroundTask];
        self.backgroundTask = UIBackgroundTaskInvalid;
    }];
</code></pre>

<p>您也可以在任务完成的时候，主动调用<code>[[UIApplication sharedApplication] endBackgroundTask:self.backgroundTask];</code> 终止任务。<br/>
程序会在后台运行，但并不是无限时间。</p>

                        
                      </div>
                  </div>
                </a>
                <div class="read-more clearfix">
                  <div class="more-left left">
                  
                    <span class="date">2015/12/16</span>
                    <span>posted in&nbsp;</span> 
          				  
          					    <span class="posted-in"><a href='Note.html'>Note</a></span>
          				   
                  </div>
                  <div class="more-right right">
                  <span class="comments">
                      

                       
                  </span>
                  </div>
                </div>
              </div><!-- article -->
        
			<div class="article">
                <a class="clearlink" href="14510343642124.html">
                
                  <h1>NSFetchedResultsController的简单封装 － UITableView与CoreData的完美结合</h1>
                  <div class="a-content">
                      
                      <div class="a-content-text">
                        
                        	<ul>
<li>
<a href="#toc_0">基本概念MVC与MVVC</a>
<ul>
<li>
<a href="#toc_1">传统MVC Model － View － Controller</a>
</li>
<li>
<a href="#toc_2">MVVC Model － View － Controller - ViewModel</a>
</li>
</ul>
</li>
<li>
<a href="#toc_3">NSFetchedResultsController</a>
<ul>
<li>
<a href="#toc_4">绑定tableView的DataSource</a>
</li>
<li>
<a href="#toc_5">绑定增删改</a>
</li>
</ul>
</li>
</ul>
</li>
<li>
<a href="#toc_6">DEFetchRC</a>
<ul>
<li>
<a href="#toc_7">DETableViewFetchRC初始化</a>
</li>
<li>
<a href="#toc_8">最终效果</a>
</li>
<li>
<a href="#toc_9">总结</a>
</li>
</ul>


<p>本文将简单分析NSFetchedResultsController这个控制器类的用法和开源控件<a href="https://github.com/zsy78191/DEFetchRC">DEFetchRC</a>的使用方法。</p>

<p>如果您在阅读本文时，对CoreData还没有任何基础概念，这里给您推荐一套来自objcio.cn的<a href="http://objcio.cn/issue-4/">CoreData系列教程</a>，相信能对您有所帮助。</p>

<h2 id="toc_0">基本概念MVC与MVVC</h2>

<p>从传统意义的MVC到MVVC的转变，相信大家都厌烦了术语套话，这些设计模式概念用自然语言描述显得十分抽象，我们今天用Cocoa的类来简单描述一下这两种模式。</p>

<h3 id="toc_1">传统MVC Model － View － Controller</h3>

<p>刚入门Cocoa时，我们接触到的最基本的类，就是UIViewController和UIView类，他们对应的MVC模型中的Controller和View,Model(数据模型)则可以是CoreData的数据，网络请求的数据，或者其他一些格式的数据，MVC的运作模式就是Controller将Model内容填入View，View响应交互让Controller处理数据并且修改View。</p>

<h3 id="toc_2">MVVC Model － View － Controller - ViewModel</h3>

<p>经过实战我们发现，Controller的代码量庞大不堪，一方面操作数据，一方面操作View，臃肿不堪，难以维护。所以MVVC模型应运而生，在MVC的基础上，加入了ViewModel概念，这个(些)ViewModel可以作为Controller的属性，剥离Controller中复杂的任务，例如：</p>

<ol>
<li>替Controller实现TableView和CollectionView的回调。</li>
<li>剥离数据库操作</li>
<li>剥离网络请求</li>
</ol>

<p>这样让Controller专注于处理View布局、交互和动画，把任务剥离，降低整体项目的耦合性。</p>

<h2 id="toc_3">NSFetchedResultsController</h2>

<p>基于高度模块化和低耦合性的设计趋势，<code>NSFetchedResultsController</code>类应运而生。<br/>
你可能还不知道这个类可以完成什么工作，头文件中如此描述：<br/>
<code><br/>
This class is intended to efficiently manage the results returned from a Core Data fetch request.<br/>
这个类用于高效地响应CoreData数据变化<br/>
</code></p>

<p>本文的Demo代码见<a href="https://github.com/zsy78191/DEFetchRC">zsy78191/DEFetchRC</a><br/>
初始化代码，这段代码摘自苹果官方模版，我们自建<code>DETableViewFetchRC</code>类用于绑定，这里在DETableViewFetchRC类中实现NSFetchedResultsController相关方法，使用的参数包括<br/>
1. self.entityName 实体名称<br/>
2. self.managedContext CoreData的上下文<br/>
3. self.predicate 检索谓语<br/>
4. self.sortKey 排序键<br/>
5. self.ascending 排序升序或降序<br/>
6. _fetchController.delegate NSFetchedResultsControllerDelegate委托</p>

<pre><code>@property (nonatomic, strong) NSFetchedResultsController* fetchController;

- (NSFetchedResultsController *)fetchController
{
    if (_fetchController != nil) {
        return _fetchController;
    }
    
    NSFetchRequest *fetchRequest = [[NSFetchRequest alloc] init];
    // Edit the entity name as appropriate.
    NSEntityDescription *entity = [NSEntityDescription entityForName:self.entityName inManagedObjectContext:self.managedContext];
    [fetchRequest setEntity:entity];
    
    // Set the batch size to a suitable number.
    [fetchRequest setFetchBatchSize:20];
    [fetchRequest setPredicate:self.predicate];
    
    // Edit the sort key as appropriate.
    NSSortDescriptor *sortDescriptor = [[NSSortDescriptor alloc] initWithKey:self.sortKey ascending:self.ascending];
    NSArray *sortDescriptors = @[sortDescriptor];
    
    [fetchRequest setSortDescriptors:sortDescriptors];
    
    // Edit the section name key path and cache name if appropriate.
    // nil for section name key path means &quot;no sections&quot;.
    _fetchController= [[NSFetchedResultsController alloc] initWithFetchRequest:fetchRequest managedObjectContext:self.managedContext sectionNameKeyPath:nil cacheName:nil];
    _fetchController.delegate = self;
    
    NSError *error = nil;
    if (![_fetchController performFetch:&amp;error]) {
        // Replace this implementation with code to handle the error appropriately.
        // abort() causes the application to generate a crash log and terminate. You should not use this function in a shipping application, although it may be useful during development.
        ////LOGMARK(@&quot;Unresolved error %@, %@&quot;, error, [error userInfo]);
        abort();
    }
    
    return _fetchController;
}
</code></pre>

<p>绑定好的NSFetchedResultsController通过KVO观察CoreData上下文变化，并通知我们修改View，具体实现如下：</p>

<h3 id="toc_4">绑定tableView的DataSource</h3>

<pre><code>- (NSInteger)numberOfSectionsInTableView:(UITableView *)tableView {
    return [[self.fetchController sections] count];
}
</code></pre>

<p><strong>注：NSFetchedResultsController是支持TableView的Section功能的，我们在这个例子中国年并没有使用，读者可以根据需要进行修改。</strong></p>

<pre><code>- (NSInteger)tableView:(UITableView *)tableView numberOfRowsInSection:(NSInteger)section {
    id &lt;NSFetchedResultsSectionInfo&gt; sectionInfo = [self.fetchController sections][section];
    return [sectionInfo numberOfObjects];
}

- (UITableViewCell *)tableView:(UITableView *)tableView cellForRowAtIndexPath:(NSIndexPath *)indexPath {
    if([self checkDataSourceCanResponse:@selector(tableView:cellAtIndexPath:withData:)])
    {
        NSManagedObject *data = [self.fetchController objectAtIndexPath:indexPath];
         
        //在这里处理Cell内容
    }
    return nil;
}
</code></pre>

<h3 id="toc_5">绑定增删改</h3>

<p>这里<code>NSFetchedResultsController</code>提供了NSFetchedResultsControllerDelegate协议，用于绑定Model和View，如下。</p>

<pre><code>#pragma mark - fetch


- (void)controllerWillChangeContent:(NSFetchedResultsController *)controller
{
    [self.tableView beginUpdates];
}

- (void)controller:(NSFetchedResultsController *)controller didChangeSection:(id &lt;NSFetchedResultsSectionInfo&gt;)sectionInfo
           atIndex:(NSUInteger)sectionIndex forChangeType:(NSFetchedResultsChangeType)type
{
    switch(type) {
        case NSFetchedResultsChangeInsert:
            [self.tableView insertSections:[NSIndexSet indexSetWithIndex:sectionIndex] withRowAnimation:UITableViewRowAnimationAutomatic];
            break;
            
        case NSFetchedResultsChangeDelete:
            [self.tableView deleteSections:[NSIndexSet indexSetWithIndex:sectionIndex] withRowAnimation:UITableViewRowAnimationLeft];
            break;
            
        default:
            return;
    }
}

- (void)controller:(NSFetchedResultsController *)controller didChangeObject:(NSManagedObject*)anObject
       atIndexPath:(NSIndexPath *)indexPath forChangeType:(NSFetchedResultsChangeType)type
      newIndexPath:(NSIndexPath *)newIndexPath
{
    UITableView *tableView = self.tableView;
    switch(type) {
        case NSFetchedResultsChangeInsert:
            [tableView insertRowsAtIndexPaths:@[newIndexPath] withRowAnimation:UITableViewRowAnimationAutomatic];
            break;
            
        case NSFetchedResultsChangeDelete:
            [tableView deleteRowsAtIndexPaths:@[indexPath] withRowAnimation:UITableViewRowAnimationLeft];
            break;
            
        case NSFetchedResultsChangeUpdate:
            [tableView reloadRowsAtIndexPaths:@[indexPath] withRowAnimation:UITableViewRowAnimationAutomatic];
            break;
            
        case NSFetchedResultsChangeMove:
            [tableView deleteRowsAtIndexPaths:@[indexPath] withRowAnimation:UITableViewRowAnimationAutomatic];
            [tableView insertRowsAtIndexPaths:@[newIndexPath] withRowAnimation:UITableViewRowAnimationAutomatic];
            break;
    }
}

- (void)controllerDidChangeContent:(NSFetchedResultsController *)controller
{
    [self.tableView endUpdates];
}

</code></pre>

<p>至此，NSFetchedResultsController的基本使用方法都介绍了，接下来介绍一下我做的一个对NSFetchedResultsController的简单封装，<a href="https://github.com/zsy78191/DEFetchRC">zsy78191/DEFetchRC</a>。</p>

<h1 id="toc_6">DEFetchRC</h1>

<p>一个NSFetchedResultsController的简单封装</p>

<p>DETableViewFetchRC将自动绑定CoreData的ManageContext和TableView，绑定好以后，数据的任何变动，包括增删改查，都会自动调用对应Cell的更新，不需要自己写任何代码做通知挂钩等。</p>

<p>Demo中使用Apple的CoreData模版，CoreData的Context在AppDelegate中。</p>

<pre><code>- (NSManagedObjectContext*)managedObjectContext
{
    AppDelegate* delegate = [UIApplication sharedApplication].delegate;
    return delegate.managedObjectContext;
}
</code></pre>

<h2 id="toc_7">DETableViewFetchRC初始化</h2>

<pre><code>@property (nonatomic, strong) DETableViewFetchRC* tableFetchResultController;

- (void)viewDidLoad {
    [super viewDidLoad];
    
    [self.managedObjectContext setUndoManager:[[NSUndoManager alloc] init]];
    
   
    self.tableFetchResultController = [DETableViewFetchRC fetchRCWithView:self.tableView
                                                                  reciver:self
                                                           managedContext:self.managedObjectContext
                                                               entityName:@&quot;Item&quot;
                                                                  sortKey:@&quot;date&quot;
                                                                ascending:YES
                                                                predicate:nil];
}
</code></pre>

<p>其中第一参数输入需要绑定（bind）的 TableView（如果使用DECollectionViewFetchRC则传入CollectionView），第二个参数是DETableViewFetchDelegate的委托，主要用来实现Cell内容填充回调：</p>

<pre><code>- (UITableViewCell *)tableView:(UITableView *)tableView cellAtIndexPath:(NSIndexPath *)indexPath withData:(id)data
{
    Item* item = data;
    UITableViewCell* cell = [tableView dequeueReusableCellWithIdentifier:@&quot;cell&quot; forIndexPath:indexPath];
    cell.textLabel.text = item.title;
    cell.detailTextLabel.text = [item.date description];
    return cell;
}
</code></pre>

<p>这里的CoreData实例名字是Item，有title和date两个属性，分别为NSString和NSDate。</p>

<p>这样就完成了一步绑定，CoreData的Context有变动时自动更新调用Cell更新回调，更新Cell，增删改都自动完成。效果如下：</p>

<h2 id="toc_8">最终效果</h2>

<p><img src="/img/bVrM4J" alt="DEFetchRCDemo.gif"/></p>

<p>详细的代码请参考<a href="https://github.com/zsy78191/DEFetchRC">zsy78191/DEFetchRC</a></p>

<h2 id="toc_9">总结</h2>

<p>本文作为<a href="http://segmentfault.com/a/1190000002498637">怎样降低iOS代码耦合性</a>一文的延伸阅读，介绍了<code>NSFetchedResultsController</code>类的基本使用方法，这个类作为CoreData的辅助控制器，在哲学高度强化了CoreData和TableView的绑定，原理上也适用于CoreData和CollectionView或其它第三方控件的绑定，灵活中不失稳重，值得细细研究一番。</p>

                        
                      </div>
                  </div>
                </a>
                <div class="read-more clearfix">
                  <div class="more-left left">
                  
                    <span class="date">2015/12/25</span>
                    <span>posted in&nbsp;</span> 
          				  
          					    <span class="posted-in"><a href='Note.html'>Note</a></span>
          				   
                  </div>
                  <div class="more-right right">
                  <span class="comments">
                      

                       
                  </span>
                  </div>
                </div>
              </div><!-- article -->
        
			<div class="article">
                <a class="clearlink" href="14500756041561.html">
                
                  <h1>SwizzleMethod的黑魔法</h1>
                  <div class="a-content">
                      
                      <div class="a-content-text">
                        
                        	<pre><code>    void swizzleMethod(Class class, SEL originalSelector, SEL swizzledSelector)
    {
        // the method might not exist in the class, but in its superclass
        Method originalMethod = class_getInstanceMethod(class, originalSelector);
        Method swizzledMethod = class_getInstanceMethod(class, swizzledSelector);
        
        // class_addMethod will fail if original method already exists
        BOOL didAddMethod = class_addMethod(class, originalSelector, method_getImplementation(swizzledMethod), method_getTypeEncoding(swizzledMethod));
        
        // the method doesn’t exist and we just added one
        if (didAddMethod) {
            class_replaceMethod(class, swizzledSelector, method_getImplementation(originalMethod), method_getTypeEncoding(originalMethod));
        }
        else {
            method_exchangeImplementations(originalMethod, swizzledMethod);
        }
    }
</code></pre>

<p>上面这个C风格函数，就是SwizzleMethod的核心方法，用来交换Runtime中类和对象的方法接口指针。但是这有什么用呢？</p>

<h2 id="toc_0">你知道有名的第三方库IQKeyboard么？</h2>

<p>这个吊库，不需要引入头文件，不需要调用任何方法就能使用。怎么做到的呢？<br/>
答案是NSObject的 <code>+ (void)load</code>方法。</p>

<p>这个类方法，在软件运行时一定会调用一次，并且不需要调用super方法，因为父类的load方法也一定会调用。</p>

<p>IQKeyboard就是在load方法中初始化的。</p>

<h2 id="toc_1">SwizzleMethod应用实例 —— 无痛手术</h2>

<p>这个比喻并不准确，准确说应该是无痕手术 —— 对方法的无痕手术</p>

<pre><code>+ (void)load
{
    swizzleMethod([AppDelegate class], @selector(application:didFinishLaunchingWithOptions:), @selector(swizzle_application:didFinishLaunchingWithOptions:));
}
</code></pre>

<p>这里，我们把AppDelegate的启动方法更换成了我们自己的swizzle_application:didFinishLaunchingWithOptions方法。两个方法指针互换，然后我们在我们的方法中加入我们需要的代码。</p>

<pre><code>- (BOOL)swizzle_application:(UIApplication *)application didFinishLaunchingWithOptions:(NSDictionary *)launchOptions
{
    //我们需要添加的代码
    //
    return [self swizzle_application:application didFinishLaunchingWithOptions:launchOptions];
}
</code></pre>

<p>注意到了么，结尾我们自己调用<code>swizzle_application:application</code>方法，因为这个这个方法指针实际已经指向<code>AppDelegate</code>的<code>application:didFinishLaunchingWithOptions</code>方法。其他地方掉用<code>AppDelegate</code>的<code>application:didFinishLaunchingWithOptions</code>方法则会指向我们的<code>swizzle_application:application</code>方法，这样我们就在人不知不觉中，向<code>AppDelegate</code>插入了一段代码，这一切不需要AppDelegate引入任何头文件，是不是很Cool？</p>

<p>这样一来就可以把需要放在这里面的各种监测代码初始化，都放到我们的<code>swizzle_application:application</code>方法中，可以给这个方法新建一个类，每次新建工程直接拖进来一起编译，分分钟植入，帅爆一切，点个赞吧。</p>

                        
                      </div>
                  </div>
                </a>
                <div class="read-more clearfix">
                  <div class="more-left left">
                  
                    <span class="date">2015/12/14</span>
                    <span>posted in&nbsp;</span> 
          				  
          					    <span class="posted-in"><a href='Note.html'>Note</a></span>
          				   
                  </div>
                  <div class="more-right right">
                  <span class="comments">
                      

                       
                  </span>
                  </div>
                </div>
              </div><!-- article -->
        
			<div class="article">
                <a class="clearlink" href="14527416808808.html">
                
                  <h1>UINavigationBar的继承与定制</h1>
                  <div class="a-content">
                      
                      <div class="a-content-text">
                        
                        	<p>我们在iOS项目开发中，有些时候需要修改标准控件的样式，我们今天就围绕一个具体项目需求，进行<code>UINavigationBar</code>的继承与改造。</p>

<h1 id="toc_0">UIApperance协议属性定制</h1>

<p>我们在<code>UINavigationBar.h</code>头文件中，看到如下修改NavigationBar背景颜色的属性</p>

<pre><code>@property(nullable, nonatomic,strong) UIColor *barTintColor NS_AVAILABLE_IOS(7_0) UI_APPEARANCE_SELECTOR;  // default is nil
</code></pre>

<p>注意到<code>UI_APPEARANCE_SELECTOR</code>这个宏了么，用这个宏标记的属性，都是可以通过<code>UIApperance</code>协议进行全局设置的属性。说的更直白一点，就是可以一次性，修改项目中所有的这个类的默认属性。</p>

<p>例如在iOS6之前，<code>UILabel</code>的默认背景颜色不是透明色，而是白色。我们就可以使用如下方法，修改<code>UILabel</code>的默认背景色</p>

<pre><code> [[UILabel appearance] setBackgroundColor:[UIColor clearColor]];
</code></pre>

<p><code>UIApperance</code>协议就是这么神奇，所有的UIKit控件都遵守了这个协议，所有标记了<code>UI_APPEARANCE_SELECTOR</code>宏的属性，都可以使用<code>appearance</code>实例修改默认值，是不是很炫酷。</p>

<h1 id="toc_1">项目需求</h1>

<p>上面一段与本文正题无关，下面我们看一下本文的项目需求</p>

<p><img src="/img/bVsd7L" alt="图片描述"/></p>

<h1 id="toc_2">分析</h1>

<p>这个页面就是一个标准的<code>NavigationController</code> + <code>TableViewContoller</code>组合实现的设置页面，导航条和Table的样式需要订制。</p>

<p>前面说到的<code>UIApperance</code>协议是可以实现的，我们换一种更为普遍的方式实现，<strong>继承</strong>。</p>

<p>我们继承<code>UINavigationBar</code>，创建子类<code>FWBar</code>。我们使用storyboard实例化大体框架模型，并将<code>NavigationViewController</code>的<code>NavigationBar</code>设置为我们的<code>FWBar</code>类，并将<code>UITableView</code>设置为<code>Static</code>静态模式，直接编辑了<code>Cell</code>的内容。</p>

<p><img src="/img/bVsd8s" alt="图片描述"/></p>

<p>在<code>FWBar.m</code>中加入如下代码<br/>
```<br/>
- (void)awakeFromNib<br/>
{<br/>
    [self setBackgroundImage:[UIImage new] forBarMetrics:UIBarMetricsCompact];<br/>
    self.shadowImage = [UIImage new];</p>

<pre><code>//把之前的View统统隐藏
[self.subviews enumerateObjectsUsingBlock:^(__kindof UIView * _Nonnull obj, NSUInteger idx, BOOL * _Nonnull stop) {
    [obj setHidden:YES];
}];


[self addSubview:self.fakeBackgroundView];
self.fakeBackgroundView.userInteractionEnabled = NO;
[self sendSubviewToBack:self.fakeBackgroundView];

self.titleTextAttributes = @{
                             NSFontAttributeName: [UIFont fontWithName:@&quot;NotoSansHans-DemiLight&quot; size:16],
                             NSForegroundColorAttributeName:[UIColor colorWithRed:57.0/255 green:207.0/255 blue:218.0/255 alpha:1]
                             };

//rgba(165, 195, 205, 1)
self.tintColor = [UIColor colorWithRed:165.0/255 green:195.0/255 blue:205.0/255 alpha:1];
</code></pre>

<p>}<br/>
```</p>

<p><strong>解释</strong> 因为原生的NaviBar背景View下方有一条灰色的边，这条边不是用layer生成的，我没搞明白是怎么实现的，所以直接将这个View隐藏掉了。顺便吧<code>shadowImage</code>也换成空图。</p>

<p>这里的<code>self.fakeBackgroundView</code>是我们添加的背景，颜色是白色。这里我们将它移到最下层，并且触摸属性关掉，<code>userInteractionEnabled</code>设为<code>NO</code>。</p>

<p><code>titleTextAttributes</code>这个属性，是用来修改title的样式的。</p>

<p><code>tintColor</code>这个属性，是用来修改导航条左右按钮颜色的。</p>

<p>这些操作做完，还不够。</p>

<p><strong>我们无法通过暴露出来的接口修改左右按钮的字体和位置。这也是我们选择继承而不是UIApperance的原因</strong></p>

<h1 id="toc_3">继承大杀器，高度自定义</h1>

<pre><code>- (void)didAddSubview:(UIView *)subview
{
    NSLog(@&quot;%@&quot;,subview);
    if ([subview isKindOfClass:NSClassFromString(@&quot;UINavigationButton&quot;)]) {
        if ([subview isKindOfClass:[UIButton class]]) {
            
            [(UIButton*)subview setAttributedTitle:[[NSAttributedString alloc] initWithString:[(UIButton*)subview titleForState:UIControlStateNormal] attributes:@{
                                                                                                                                                                   NSFontAttributeName: [UIFont fontWithName:@&quot;AvenirNext-Regular&quot; size:17],
                                                                                                                                                                   NSForegroundColorAttributeName:self.tintColor
                                                                                                                                                                   }] forState:UIControlStateNormal];
        }
    }
}

- (void)layoutSubviews
{
    [super layoutSubviews];
    
    [self.subviews enumerateObjectsUsingBlock:^(__kindof UIView * _Nonnull subview, NSUInteger idx, BOOL * _Nonnull stop) {
        if ([subview isKindOfClass:NSClassFromString(@&quot;UINavigationButton&quot;)]) {
            if ([subview isKindOfClass:[UIButton class]] &amp;&amp; subview.frame.origin.x &lt; self.frame.size.width/2) {
                [subview setFrame:({
                    CGRect rect = subview.frame;
                    rect.origin.x = 8;
                    rect.size.width = 69;
                    rect;
                })];
            }
        }
        
    }];
}
</code></pre>

<p><strong>解释</strong> 重写<code>- (void)didAddSubview:(UIView *)subview</code>方法，检测了系统控件根据<code>NavigationItem</code>向<code>NavigationBar</code>添加按钮这个事件，然后对按钮进行甄别，定制。</p>

<p>我们找到<code>Cancel</code>这个按钮，他虽然是<code>UINavigationButton</code>类型，但是一定是继承了<code>UIButton</code>，所以我们直接强转成她的父类，修改其文字字体和frame。</p>

<p>重写<code>layoutSubviews</code>这个方法，是为了实时更新我们的按钮位置。这个其实也可以不更改的，但是我们的项目需求中，<code>Cancel</code>这个字段太长，字体变大以后导致了显示不全，所以我们将这个做按钮的frame变大了。</p>

<p>注意几点</p>

<ol>
<li><p><code>NSClassFromString(@&quot;UINavigationButton&quot;)</code>这个方法是我们无法获取内部类的时候，获取Class类型的方法。<code>UINavigationButton</code>这个类名是NSLog输出时看到的。</p></li>
<li><p>这一段使用了特殊的语法糖，有兴趣了解的参考<a href="http://blog.sunnyxx.com/2014/08/02/objc-weird-code/">这篇sunnyxx大神的博文</a>，全文搜索关键字<code>小括号内联复合表达式</code></p></li>
</ol>

<pre><code>[subview setFrame:({
                    CGRect rect = subview.frame;
                    rect.origin.x = 8;
                    rect.size.width = 69;
                    rect;
                })];
</code></pre>

<p>最后的实现效果。</p>

<p><img src="/img/bVseck" alt="图片描述"/></p>

<h1 id="toc_4">结语</h1>

<p>截屏的效果不是太好，细心的朋友可能会发现，我们的<code>FWBar</code>在<code>TableView</code>向上滑动的过程中会渐出阴影。</p>

<p>我把这段代码分享给大家，但是这段代码偷懒没用KVO，而是用了<code>ReactiveCocoa</code>这个庞大的庞大框架的小小功能，所以，就没放倒教程里。</p>

<pre><code>- (void)didMoveToSuperview
{
    [super didMoveToSuperview];
    
    UIViewController *presentingViewController = [UIApplication sharedApplication].keyWindow.rootViewController;
    while (presentingViewController.presentedViewController) presentingViewController = presentingViewController.presentedViewController;

    __block BOOL has = NO;
    [[presentingViewController childViewControllers] enumerateObjectsUsingBlock:^(__kindof UIViewController * _Nonnull obj, NSUInteger idx, BOOL * _Nonnull stop) {
        if ([obj isKindOfClass:[UINavigationController class]]) {
            [[obj childViewControllers] enumerateObjectsUsingBlock:^(__kindof UIViewController * _Nonnull obj2, NSUInteger idx, BOOL * _Nonnull stop) {
                if ([obj2 isKindOfClass:[UITableViewController class]]) {
                    has = YES;
                    UITableViewController* tVC = obj2;
                    if (self.tableViewOffsetDisposable) {
                        [self.tableViewOffsetDisposable dispose];
                    }
                    self.tableViewOffsetDisposable = [RACObserve(tVC.tableView, contentOffset) subscribeNext:^(id x) {
                        CGPoint p = [x CGPointValue];
                        
                        if (p.y &lt;= 0 &amp;&amp; p.y &gt;= - 64) {
                            self.fakeBackgroundView.layer.shadowOpacity = fabs(64 + p.y) / 64 * 0.7;
                        }
                        else if (p.y &gt; 0)
                        {
                            if (self.fakeBackgroundView.layer.shadowOpacity != 0.7) {
                                self.fakeBackgroundView.layer.shadowOpacity = 0.7;
                            }
                        }
                        else
                        {
                            if (self.fakeBackgroundView.layer.shadowOpacity != 0) {
                                self.fakeBackgroundView.layer.shadowOpacity = 0;
                            }
                        }
                    }];
                }
            }];
        }
    }];
}
</code></pre>

                        
                      </div>
                  </div>
                </a>
                <div class="read-more clearfix">
                  <div class="more-left left">
                  
                    <span class="date">2016/1/14</span>
                    <span>posted in&nbsp;</span> 
          				  
          					    <span class="posted-in"><a href='Note.html'>Note</a></span>
          				   
                  </div>
                  <div class="more-right right">
                  <span class="comments">
                      

                       
                  </span>
                  </div>
                </div>
              </div><!-- article -->
        
			<div class="article">
                <a class="clearlink" href="14509257553074.html">
                
                  <h1>UITableView 编辑模式详解</h1>
                  <div class="a-content">
                      
                      <div class="a-content-text">
                        
                        	<p><code>UITableView</code>的相关编辑操作非常全，今天我们来做一个总结。跟编辑相关的属性和接口有如下，我们一个一个分析，我们先认真阅读一下相关头文件，我根据意思大概翻译了一下注释。</p>

<h2 id="toc_0">属性方法</h2>

<pre><code>@property (nonatomic, getter=isEditing) BOOL editing;                             
// 默认状态是非编辑状态，如果不调用下面接口直接设置，是没有动画的
- (void)setEditing:(BOOL)editing animated:(BOOL)animated;
</code></pre>

<h2 id="toc_1">DataSource</h2>

<pre><code>// 当增减按钮按下时，用来处理数据和UI的回调。
// 8.0版本后加入的UITableViewRowAction不在这个回调的控制范围内，UITableViewRowAction有单独的回调Block。
- (void)tableView:(UITableView *)tableView commitEditingStyle:(UITableViewCellEditingStyle)editingStyle forRowAtIndexPath:(NSIndexPath *)indexPath;

// 这个回调实现了以后，就会出现更换位置的按钮，回调本身用来处理更换位置后的数据交换。
- (void)tableView:(UITableView *)tableView moveRowAtIndexPath:(NSIndexPath *)sourceIndexPath toIndexPath:(NSIndexPath *)destinationIndexPath;

// 这个回调决定了在当前indexPath的Cell是否可以编辑。
- (BOOL)tableView:(UITableView *)tableView canEditRowAtIndexPath:(NSIndexPath *)indexPath;

// 这个回调决定了在当前indexPath的Cell是否可以移动。
- (BOOL)tableView:(UITableView *)tableView canMoveRowAtIndexPath:(NSIndexPath *)indexPath;
</code></pre>

<h2 id="toc_2">Delegate</h2>

<pre><code>// 这个回调很关键，返回Cell的编辑样式。
- (UITableViewCellEditingStyle)tableView:(UITableView *)tableView editingStyleForRowAtIndexPath:(NSIndexPath *)indexPath;

// 删除按钮的文字
- (nullable NSString *)tableView:(UITableView *)tableView titleForDeleteConfirmationButtonForRowAtIndexPath:(NSIndexPath *)indexPath NS_AVAILABLE_IOS(3_0) __TVOS_PROHIBITED;

// 8.0后侧滑菜单的新接口，支持多个侧滑按钮。
- (nullable NSArray&lt;UITableViewRowAction *&gt; *)tableView:(UITableView *)tableView editActionsForRowAtIndexPath:(NSIndexPath *)indexPath NS_AVAILABLE_IOS(8_0) __TVOS_PROHIBITED;

// 这个接口决定编辑状态下的Cell是否需要缩进。
- (BOOL)tableView:(UITableView *)tableView shouldIndentWhileEditingRowAtIndexPath:(NSIndexPath *)indexPath;

// 这是两个状态回调
- (void)tableView:(UITableView*)tableView willBeginEditingRowAtIndexPath:(NSIndexPath *)indexPath __TVOS_PROHIBITED;
- (void)tableView:(UITableView*)tableView didEndEditingRowAtIndexPath:(NSIndexPath *)indexPath __TVOS_PROHIBITED;
</code></pre>

<h2 id="toc_3">编辑状态</h2>

<p><code>UITableView</code>通过editing属性控制编辑状态，调用<code>- (void)setEditing:(BOOL)editing animated:(BOOL)animated</code>接口，可以决定是否使用原生的变换动画。</p>

<p>当调用这个接口，并将editing设为<code>YES</code>是，<code>UITableView</code>将开始询问代理(Delegate)需要编辑哪些Cell，用什么样的方式编辑。</p>

<p>首先调用回调方法<code>- (BOOL)tableView:(UITableView *)tableView canEditRowAtIndexPath:(NSIndexPath *)indexPath;</code>，这里需要返回YES；</p>

<p>然后依次为各个Cell调用<code>- (UITableViewCellEditingStyle)tableView:(UITableView *)tableView editingStyleForRowAtIndexPath:(NSIndexPath *)indexPath;</code>方法获取编辑样式。</p>

<pre><code>typedef NS_ENUM(NSInteger, UITableViewCellEditingStyle) {
    UITableViewCellEditingStyleNone,
    UITableViewCellEditingStyleDelete,
    UITableViewCellEditingStyleInsert
};
</code></pre>

<p>编辑样式枚举有三种，位运算组合则由不同的用途。</p>

<pre><code>UITableViewCellEditingStyleNone 没有编辑样式
UITableViewCellEditingStyleDelete 删除样式 （左边是红色减号）
UITableViewCellEditingStyleInsert 插入样式  (左边是绿色加号)
UITableViewCellEditingStyleDelete|UITableViewCellEditingStyleInsert 多选模式，左边是蓝色对号
</code></pre>

<p>特别注意，右边的移动并不是这里控制的，需要实现下面这个回调才会出现。<br/>
<code><br/>
- (void)tableView:(UITableView *)tableView moveRowAtIndexPath:(NSIndexPath *)sourceIndexPath toIndexPath:(NSIndexPath *)destinationIndexPath;<br/>
</code></p>

<p>另外对于新手来说，要明白这里的回调都没有对UI和数据进行操作，开发者需要在回调中，完成相应的操作。比如删除或者添加一条数据，应在</p>

<pre><code>- (void)tableView:(UITableView *)tableView commitEditingStyle:(UITableViewCellEditingStyle)editingStyle forRowAtIndexPath:(NSIndexPath *)indexPath;
</code></pre>

<p>上面这个回调中，根据editingStyle进行判断，处理对应的UI和数据。</p>

<h2 id="toc_4">数据与UI更新</h2>

<p>数据更新没什么好说的，直接操作数据容器就好，无论是数组、字典还是CoreData数据。UI更新则需要使用TableView的方法，如果需求reloadData无法满足，则必须使用下面的方法</p>

<pre><code>- (void)beginUpdates;   // allow multiple insert/delete of rows and sections to be animated simultaneously. Nestable
- (void)endUpdates;     // only call insert/delete/reload calls or change the editing state inside an update block.  otherwise things like row count, etc. may be invalid.

- (void)insertSections:(NSIndexSet *)sections withRowAnimation:(UITableViewRowAnimation)animation;
- (void)deleteSections:(NSIndexSet *)sections withRowAnimation:(UITableViewRowAnimation)animation;
- (void)reloadSections:(NSIndexSet *)sections withRowAnimation:(UITableViewRowAnimation)animation NS_AVAILABLE_IOS(3_0);
- (void)moveSection:(NSInteger)section toSection:(NSInteger)newSection NS_AVAILABLE_IOS(5_0);

- (void)insertRowsAtIndexPaths:(NSArray&lt;NSIndexPath *&gt; *)indexPaths withRowAnimation:(UITableViewRowAnimation)animation;
- (void)deleteRowsAtIndexPaths:(NSArray&lt;NSIndexPath *&gt; *)indexPaths withRowAnimation:(UITableViewRowAnimation)animation;
- (void)reloadRowsAtIndexPaths:(NSArray&lt;NSIndexPath *&gt; *)indexPaths withRowAnimation:(UITableViewRowAnimation)animation NS_AVAILABLE_IOS(3_0);
- (void)moveRowAtIndexPath:(NSIndexPath *)indexPath toIndexPath:(NSIndexPath *)newIndexPath NS_AVAILABLE_IOS(5_0);
</code></pre>

<p><code>beginUpdates</code>和<code>endUpdates</code>两个方法，在你需要批量处理Cell的时候，用来包裹住你的处理代码，其他方法名字都很直观，不一一介绍了。</p>

<p>最后给大家推荐一个Cocoa框架里的功能强大的类<code>NSFetchedResultsController</code>，用于绑定CoreData数据和<code>UITableView</code>或者<code>UICollectionView</code>，直接封装好所有的UI操作代码，只要数据有变动，UI自动更新，爽的不要不要的，妈妈再也不用担心我的TableView写不好了，下一篇文章我准备详细讲一讲这个有趣的类。</p>

                        
                      </div>
                  </div>
                </a>
                <div class="read-more clearfix">
                  <div class="more-left left">
                  
                    <span class="date">2015/12/24</span>
                    <span>posted in&nbsp;</span> 
          				  
          					    <span class="posted-in"><a href='Note.html'>Note</a></span>
          				   
                  </div>
                  <div class="more-right right">
                  <span class="comments">
                      

                       
                  </span>
                  </div>
                </div>
              </div><!-- article -->
        
			<div class="article">
                <a class="clearlink" href="14507680404000.html">
                
                  <h1>iOS 本地化入门教程</h1>
                  <div class="a-content">
                      
                      <div class="a-content-text">
                        
                        	<p>iOS应用的本地化原理非常简单，是通过<code>strings</code>类型的文件，为同一种语言的不同翻译设置翻译表，应用再根据用户系统语言自动检索翻译表实现的。</p>

<p>首先普及一些基本概念给新人看。</p>

<h2 id="toc_0">NSBundle</h2>

<p>在iOS应用中，bundle的概念非常重要，可以理解为一些文件的集合，bundle中可以嵌套bundle，外在 形式是.bundle格式的文件，同时编译生成的app包，也是bundle。</p>

<p>为此，苹果的工程师们留下了NSBundle这个类，用于操作bundle内的文件。而NSBundle类中的一些特定方法，则是给一些特定的文件实用的。</p>

<p>例如<code>infoDictionary</code>用于读取bundle中的info.plist文件。<br/>
<code><br/>
@property (nullable, readonly, copy) NSDictionary&lt;NSString *, id&gt; *infoDictionary;<br/>
</code></p>

<p>当然还有我们今天要讲的本地化方法<br/>
<code><br/>
/* Method for retrieving localized strings. */<br/>
- (NSString *)localizedStringForKey:(NSString *)key value:(nullable NSString *)value table:(nullable NSString *)tableName NS_FORMAT_ARGUMENT(1);<br/>
</code></p>

<p>这个方法就是用来读去bundle中本地化字段的方法。而在日常使用中，我们用的更多的是两个简化的宏：</p>

<pre><code>NSLocalizedString(&lt;#key#&gt;, &lt;#comment#&gt;)
NSLocalizedStringFromTable(&lt;#key#&gt;, &lt;#tbl#&gt;, &lt;#comment#&gt;)
</code></pre>

<pre><code>宏定义

#define NSLocalizedString(key, comment) \
        [[NSBundle mainBundle] localizedStringForKey:(key) value:@&quot;&quot; table:nil]
#define NSLocalizedStringFromTable(key, tbl, comment) \
        [[NSBundle mainBundle] localizedStringForKey:(key) value:@&quot;&quot; table:(tbl)]
#define NSLocalizedStringFromTableInBundle(key, tbl, bundle, comment) \
        [bundle localizedStringForKey:(key) value:@&quot;&quot; table:(tbl)]
#define NSLocalizedStringWithDefaultValue(key, tbl, bundle, val, comment) \
        [bundle localizedStringForKey:(key) value:(val) table:(tbl)]
</code></pre>

<p><code>key</code>参数必填，<code>comment</code>作为注释参数，是不影响返回值的，可以传nil。</p>

<h2 id="toc_1">默认本地化文件</h2>

<p>新工程中是不包含本地化文件的，如果要给应用添加本地化，首先需要添加<code>Localizable.strings</code>文件。</p>

<p><img src="/img/bVrH9C" alt="图片描述"/></p>

<p><code>Localizable.strings</code>文件就是本地化文件中的默认文件，名字不要打错哦，当你使用<code>NSLocalizedString(&lt;#key#&gt;, &lt;#comment#&gt;)</code>宏时，不用输入table名称，便是默认使用<code>Localizable.strings</code>文件作为翻译表。</p>

<p>如果你还有其他的翻译表文件，例如other.strings，你可以这样使用<br/>
<code><br/>
NSLocalizedStringFromTable(@&quot;你好&quot;, @&quot;other&quot;, nil)<br/>
</code><br/>
当然现在并不会将你好翻译成其他语言，下一步，你需要设置你的翻译表。</p>

<h2 id="toc_2">Localizable.strings格式</h2>

<p>strings文件的格式非常简单，但如果格式有错，编译器会报错，并且不会提醒你到底哪里错了，所以务必要仔细。如下<br/>
<code><br/>
&quot;你好&quot; = &quot;你好&quot;;<br/>
</code></p>

<ol>
<li>每一行一句，等号前面是key,等号后面是value,引号前不加<code>@</code>，分号结尾。</li>
<li>当添加多种语言后，同一个文件将会有不同语言的副本，存在工程目录下的不同本地化文件夹中，但在xcode中还是以同一个文件显示，但可以下拉切换语言进行编辑。</li>
</ol>

<p>添加本地化语言的方法如下，先选中<code>strings</code>文件，然后又边点击<code>Localize</code>按钮，然后选项中会有Base和English两个选项，确认后，这里会出现多选框，选取哪种语言，便会自动生成对应的副本。</p>

<p><img src="/img/bVrIaO" alt="图片描述"/></p>

<h3 id="toc_3">添加其他语言</h3>

<p>如图选择Project的Info标签，设置Localization选项<br/>
<img src="/img/bVrIa8" alt="图片描述"/></p>

<h2 id="toc_4">实战</h2>

<p>这里我们添加了简体中文和日本本地化，对应的Localizable.strings文件多了两个副本。</p>

<p><img src="/img/bVrIbx" alt="图片描述"/></p>

<p>各个文件中的内容如下</p>

<pre><code>//日语Localizable.strings(Japanese)文件
&quot;你好&quot; ＝ &quot;こんにちは&quot;;

//英语Localizable.strings(English)文件
&quot;你好&quot; ＝ &quot;hello&quot;;

//简体中文Localizable.strings(Simplified)文件
&quot;你好&quot; ＝ &quot;你好&quot;;
</code></pre>

<p>这样一来，当我们在代码中使用<q>你好</q>这个key时，系统便会自动根据我们的系统语言，进行本地化替换，当系统语言并非我们本地化支持的语言时，例如我们并未加入韩语，本地化接口便会把key的默认语言的本地化内容返回，或者根据设备的第二语言进行返回。当使用的key并不存在时，则会把key作为value返回。</p>

<h2 id="toc_5">开源工具</h2>

<p>这里给大家分享一个我写的<a href="https://github.com/zsy78191/SimpleLocalizedTool">开源项目</a>，可以自动给.m和.mm文件，生成对应的翻译表。<br/>
例如代码中使用本地化方法<br/>
<code><br/>
NSString* a = NSLocalizedString(@&quot;这是一个测试&quot;, nil);<br/>
NSString* b = NSLocalizedString(@&quot;第一条是普通本地化, 翻译写入Localizable.strings文件&quot;, nil);<br/>
NSString* c = NSLocalizedString(@&quot;第二条是带注释的语句&quot;, @&quot;这里是这条本地化语句的注释&quot;);<br/>
NSString* d = NSLocalizedStringFromTable(@&quot;第三条是带表名的本地化语句，写在 XXX(表名).strings文件里&quot;, @&quot;OtherFile&quot;,nil);<br/>
NSString* e = NSLocalizedStringFromTable( @&quot;最后一条测试书写规范，空格，特殊符号(\&quot;{@#$)等等&quot;  ,   @&quot;OtherFile&quot;  ,   nil);<br/>
</code></p>

<p>只要将文件拖入SimpleLocalizedTool工具，便会自动生成对应的本地化文件。<br/>
上面的例子中，有使用默认的string文件语句，也有使用<code>OtherFile</code>这个文件名的语句，所以会生成两个文件，内容如下，直接拷贝到工程中吧，是不是很好用呀。</p>

<pre><code>//Localizable.strings

&quot;这是一个测试&quot; = &quot;这是一个测试&quot;;
&quot;第一条是普通本地化, 翻译写入Localizable.strings文件&quot; = &quot;第一条是普通本地化, 翻译写入Localizable.strings文件&quot;;
&quot;第二条是带注释的语句&quot; = &quot;第二条是带注释的语句&quot;;


//OtherFile.strings

&quot;第三条是带表名的本地化语句，写在 XXX(表名).strings文件里&quot; = &quot;第三条是带表名的本地化语句，写在 XXX(表名).strings文件里&quot;;
&quot;最后一条测试书写规范，空格，特殊符号(\&quot;{@#$)等等&quot; = &quot;最后一条测试书写规范，空格，特殊符号(\&quot;{@#$)等等&quot;;
</code></pre>

                        
                      </div>
                  </div>
                </a>
                <div class="read-more clearfix">
                  <div class="more-left left">
                  
                    <span class="date">2015/12/22</span>
                    <span>posted in&nbsp;</span> 
          				  
          					    <span class="posted-in"><a href='Note.html'>Note</a></span>
          				   
                  </div>
                  <div class="more-right right">
                  <span class="comments">
                      

                       
                  </span>
                  </div>
                </div>
              </div><!-- article -->
        
			<div class="article">
                <a class="clearlink" href="14508532042041.html">
                
                  <h1>iOS 本地化进阶教程</h1>
                  <div class="a-content">
                      
                      <div class="a-content-text">
                        
                        	<p>在<a href="http://segmentfault.com/a/1190000004182437">上一篇</a>入门教程中，我们已经介绍了最基本的本地化方法了，接下来我们要来讲讲两种特殊的本地化情况。</p>

<h2 id="toc_0">xib和storyboard本地化</h2>

<p><code>xib</code>和<code>storyboard</code>作为两种不同类型的UI工具，让我们得以摆脱代码布局之苦，他们的本地化，既可以使用上一篇文章中的方法通过代码修改，也可以直接对xib和storyboard文件进行本地化操作，操作类似strings文件的Localize操作，见下图</p>

<p><img src="/img/bVrJBX" alt="图片描述"/></p>

<p>选中文件后，点击右边栏<code>Localize</code>按钮，勾选对应语言。</p>

<p><img src="/img/bVrJB0" alt="图片描述"/></p>

<p>这样我们发现在Storyboard文件中，包含了Chinese版本的Strings文件，内容如下</p>

<pre><code>
/* Class = &quot;UILabel&quot;; text = &quot;用户名&quot;; ObjectID = &quot;8f2-qK-7KS&quot;; */
&quot;8f2-qK-7KS.text&quot; = &quot;用户名&quot;;

/* Class = &quot;UIButton&quot;; normalTitle = &quot;登录或注册&quot;; ObjectID = &quot;ENI-bN-wSs&quot;; */
&quot;ENI-bN-wSs.normalTitle&quot; = &quot;登录或注册&quot;;

/* Class = &quot;UIButton&quot;; normalTitle = &quot;上一步&quot;; ObjectID = &quot;IGn-o3-iJc&quot;; */
&quot;IGn-o3-iJc.normalTitle&quot; = &quot;上一步&quot;;

/* Class = &quot;UILabel&quot;; text = &quot;用户名&quot;; ObjectID = &quot;YHI-In-kPq&quot;; */
&quot;YHI-In-kPq.text&quot; = &quot;用户名&quot;;

/* Class = &quot;UIButton&quot;; normalTitle = &quot;登录或注册&quot;; ObjectID = &quot;hzS-mR-s9E&quot;; */
&quot;hzS-mR-s9E.normalTitle&quot; = &quot;登录或注册&quot;;

/* Class = &quot;UILabel&quot;; text = &quot;标题&quot;; ObjectID = &quot;rjb-sh-ADV&quot;; */
&quot;rjb-sh-ADV.text&quot; = &quot;标题&quot;;

/* Class = &quot;UILabel&quot;; text = &quot;标题&quot;; ObjectID = &quot;wxc-43-QK7&quot;; */
&quot;wxc-43-QK7.text&quot; = &quot;标题&quot;;

/* Class = &quot;UIButton&quot;; normalTitle = &quot;用户使用协议&quot;; ObjectID = &quot;xdy-郭佳-fv1&quot;; */
&quot;xdy-郭佳-fv1.normalTitle&quot; = &quot;用户使用协议&quot;;
</code></pre>

<p>英文作为项目设置的基础语言，直接使用storyboard内容，中文的本地化，则由这个strings文件控制，是不是很简单。</p>

<h2 id="toc_1">info.plist的本地化</h2>

<p>第二种特殊的本地化需求是对info.plist文件进行本地化。具体的最常见的使用场景有：</p>

<ol>
<li>应用名称本地化</li>
<li>定位请求提示语本地化</li>
</ol>

<p>我们知道系统默认的本地化文件名，叫做<code>Localizable.strings</code>，info.plist文件也有自己对应的本地化文件，叫做<code>InfoPlist.strings</code></p>

<p>这个文件需要开发者自己添加，我们添加好以后，在info.plist中加入｀CFBundleDisplayName｀键值，这个键值决定应用显示的名字。</p>

<p>接下来在InfoPlist.strings文件中写入本地化索引，注意<code>CFBundleDisplayName</code>前后没有引号，这个文件是专门用来本地化info.plist文件的。<br/>
<code><br/>
CFBundleDisplayName = &quot;你的软件名称&quot;;<br/>
NSLocationAlwaysUsageDescription = &quot;我需要使用手机的定位服务，请授权&quot;;<br/>
</code><br/>
<code>NSLocationAlwaysUsageDescription</code>键值则是位置服务授权时候的提示语。如此一来就实现了info.plist文件本地化，是不是很简单？</p>

<p>我们的本地化教学就告一段落了，有其他问题请留言哦。</p>

                        
                      </div>
                  </div>
                </a>
                <div class="read-more clearfix">
                  <div class="more-left left">
                  
                    <span class="date">2015/12/23</span>
                    <span>posted in&nbsp;</span> 
          				  
          					    <span class="posted-in"><a href='Note.html'>Note</a></span>
          				   
                  </div>
                  <div class="more-right right">
                  <span class="comments">
                      

                       
                  </span>
                  </div>
                </div>
              </div><!-- article -->
        
			<div class="article">
                <a class="clearlink" href="14506845151229.html">
                
                  <h1>iOS系统授权开发</h1>
                  <div class="a-content">
                      
                      <div class="a-content-text">
                        
                        	<p>iOS系统开发中，最常用的系统授权，莫过于<code>系统通知</code>,<code>用户相册</code>,<code>位置服务</code>了，这篇文章将简单讲解这三项功能的开发，并附带我写的一个<a href="https://github.com/zsy78191/DeviceAccessViewController">开源项目</a>，统一管理系统授权。</p>

<p>注：本文和项目基于<code>iOS 8.0</code>及以上系统框架，低版本框架接口略有不同。</p>

<p><img src="/img/bVrGHs" alt="截图"/></p>

<h2 id="toc_0">系统通知授权</h2>

<p>系统通知方法在UIApplication类方法中，其中使用<code>isRegisteredForRemoteNotifications</code>获取本地推送授权状态。</p>

<pre><code>+ (UIUserNotificationType)notificationType
{
    UIApplication* application = [UIApplication sharedApplication];
    return  [application currentUserNotificationSettings].types;
}
</code></pre>

<p>这里授权状态的枚举类型有<br/>
1. <code>UIUserNotificationTypeNone</code> 无授权<br/>
2. <code>UIUserNotificationTypeBadge</code> 角标<br/>
3. <code>UIUserNotificationTypeSound</code> 声音<br/>
4. <code>UIUserNotificationTypeAlert</code> 通知</p>

<p>原枚举如下<br/>
<code><br/>
typedef NS_OPTIONS(NSUInteger, UIUserNotificationType) {<br/>
    UIUserNotificationTypeNone    = 0,      // the application may not present any UI upon a notification being received<br/>
    UIUserNotificationTypeBadge   = 1 &lt;&lt; 0, // the application may badge its icon upon a notification being received<br/>
    UIUserNotificationTypeSound   = 1 &lt;&lt; 1, // the application may play a sound upon a notification being received<br/>
    UIUserNotificationTypeAlert   = 1 &lt;&lt; 2, // the application may display an alert upon a notification being received<br/>
} NS_ENUM_AVAILABLE_IOS(8_0) __TVOS_PROHIBITED;<br/>
</code></p>

<p>授权方法<br/>
<code><br/>
UIUserNotificationType type = UIUserNotificationTypeBadge | UIUserNotificationTypeAlert | UIUserNotificationTypeSound;<br/>
UIUserNotificationSettings *setting = [UIUserNotificationSettings settingsForTypes:type categories:nil];<br/>
[[UIApplication sharedApplication] registerUserNotificationSettings:setting];<br/>
</code></p>

<p>注意，每一项授权，一旦用户拒绝，必须前往<code>设置</code>的相关APP页面开启。APP内跳<code>设置</code>的方法是</p>

<pre><code>[[UIApplication sharedApplication] openURL:[NSURL URLWithString:UIApplicationOpenSettingsURLString]];
</code></pre>

<p>注册本地通知也是有回调的，实现<code>UIApplicationDelegate</code>的<code>didRegisterUserNotificationSettings</code>方法。<br/>
```<br/>
- (void)application:(UIApplication *)application didRegisterUserNotificationSettings:(UIUserNotificationSettings *)notificationSettings<br/>
{</p>

<p>}<br/>
```</p>

<p>相应的也有失败的回调。</p>

<h2 id="toc_1">系统相册授权</h2>

<p>8.0系统版本以后，框架中加入了<code>Photos.framework</code>框架，当然是用<code>UIImagePickerController</code>同样会提醒用户授权使用相册或相机，这里介绍一下<code>Photos</code>框架的授权。</p>

<p>相册权限状态<br/>
<code><br/>
+ (PHAuthorizationStatus)photoAccesStatus<br/>
{<br/>
    return [PHPhotoLibrary authorizationStatus];<br/>
}<br/>
</code></p>

<pre><code>typedef NS_ENUM(NSInteger, PHAuthorizationStatus) {
    PHAuthorizationStatusNotDetermined = 0, // User has not yet made a choice with regards to this application
    PHAuthorizationStatusRestricted,        // This application is not authorized to access photo data.
                                            // The user cannot change this application’s status, possibly due to active restrictions
                                            //   such as parental controls being in place.
    PHAuthorizationStatusDenied,            // User has explicitly denied this application access to photos data.
    PHAuthorizationStatusAuthorized         // User has authorized this application to access photos data.
} NS_AVAILABLE_IOS(8_0);
</code></pre>

<p>这里授权状态有四个状态<br/>
1. <code>PHAuthorizationStatusNotDetermined</code> 未授权<br/>
2. <code>PHAuthorizationStatusRestricted</code> 授权中<br/>
3. <code>PHAuthorizationStatusDenied</code> 拒绝<br/>
4. <code>PHAuthorizationStatusAuthorized</code> 已授权</p>

<p>授权Block方法<br/>
```<br/>
 [PHPhotoLibrary requestAuthorization:<sup>PHAuthorizationStatus status</sup> {</p>

<p>}];<br/>
```</p>

<h2 id="toc_2">位置服务授权</h2>

<p>位置服务授权稍微复杂一点点，8.0以后，进行位置服务授权要注意一点是，需要在工程的<code>Info.plist</code>文件中加入<code>NSLocationAlwaysUsageDescription</code>字段。字段中是开发者展示给用户的位置服务的使用场景介绍，或者是请求授权的描述。如果不添加这个字段，授权接口无任何反应。</p>

<p>状态接口<br/>
<code><br/>
+ (CLAuthorizationStatus)positionAuthorizationStatus<br/>
{<br/>
    return [CLLocationManager authorizationStatus];<br/>
}<br/>
</code></p>

<p>授权方法<br/>
<code><br/>
+ (void)authorizedPosition:(CLLocationManager *)manager<br/>
{<br/>
    [manager requestAlwaysAuthorization];<br/>
}<br/>
</code></p>

<p>注意这里传入的manager一定要是个<code>property</code>,如果是一个局部变量，大括号结束，释放掉了，授权就会消失，就会出现授权框一闪而过的现象。</p>

<p><a href="https://github.com/zsy78191/DeviceAccessViewController">开源项目 DeviceAccessViewController</a></p>

                        
                      </div>
                  </div>
                </a>
                <div class="read-more clearfix">
                  <div class="more-left left">
                  
                    <span class="date">2015/12/21</span>
                    <span>posted in&nbsp;</span> 
          				  
          					    <span class="posted-in"><a href='Note.html'>Note</a></span>
          				   
                  </div>
                  <div class="more-right right">
                  <span class="comments">
                      

                       
                  </span>
                  </div>
                </div>
              </div><!-- article -->
        
			<div class="article">
                <a class="clearlink" href="14503342491175.html">
                
                  <h1>iOS设备授权全解析</h1>
                  <div class="a-content">
                      
                      <div class="a-content-text">
                        
                        	<h2 id="toc_0">通知</h2>

<pre><code>@interface UIApplication (UIRemoteNotifications)

// Calling this will result in either application:didRegisterForRemoteNotificationsWithDeviceToken: or application:didFailToRegisterForRemoteNotificationsWithError: to be called on the application delegate. Note: these callbacks will be made only if the application has successfully registered for user notifications with registerUserNotificationSettings:, or if it is enabled for Background App Refresh.

- (void)registerForRemoteNotifications NS_AVAILABLE_IOS(8_0);

- (void)unregisterForRemoteNotifications NS_AVAILABLE_IOS(3_0);

// Returns YES if the application is currently registered for remote notifications, taking into account any systemwide settings; doesn&#39;t relate to connectivity.
- (BOOL)isRegisteredForRemoteNotifications NS_AVAILABLE_IOS(8_0);

- (void)registerForRemoteNotificationTypes:(UIRemoteNotificationType)types NS_DEPRECATED_IOS(3_0, 8_0, &quot;Please use registerForRemoteNotifications and registerUserNotificationSettings: instead&quot;) __TVOS_PROHIBITED;

// Returns the enabled types, also taking into account any systemwide settings; doesn&#39;t relate to connectivity.
- (UIRemoteNotificationType)enabledRemoteNotificationTypes NS_DEPRECATED_IOS(3_0, 8_0, &quot;Please use -[UIApplication isRegisteredForRemoteNotifications], or -[UIApplication currentUserNotificationSettings] to retrieve user-enabled remote notification and user notification settings&quot;) __TVOS_PROHIBITED;

@end
</code></pre>

                        
                      </div>
                  </div>
                </a>
                <div class="read-more clearfix">
                  <div class="more-left left">
                  
                    <span class="date">2015/12/17</span>
                    <span>posted in&nbsp;</span> 
          				  
          					    <span class="posted-in"><a href='Note.html'>Note</a></span>
          				   
                  </div>
                  <div class="more-right right">
                  <span class="comments">
                      

                       
                  </span>
                  </div>
                </div>
              </div><!-- article -->
        
			<div class="article">
                <a class="clearlink" href="14513778158453.html">
                
                  <h1>opencv 学习笔记</h1>
                  <div class="a-content">
                      
                      <div class="a-content-text">
                        
                        	<p>Mat() 构造函数</p>

<pre><code>cv::Mat mat(2,2, CV_8UC3, cv::Scalar(0,0,255));
</code></pre>

<p>为已存在IplImage指针创建信息头:</p>

<pre><code>IplImage* img = cvLoadImage(&quot;greatwave.png&quot;, 1);
Mat mtx(img); // convert IplImage* -&gt; Mat
</code></pre>

<p>Create() function: 函数，这个创建方法不能为矩阵设初值，它只是在改变尺寸时重新为矩阵数据开辟内存。</p>

<pre><code>M.create(4,4, CV_8UC(2));
cout &lt;&lt; &quot;M = &quot;&lt;&lt; endl &lt;&lt; &quot; &quot;  &lt;&lt; M &lt;&lt; endl &lt;&lt; endl;
</code></pre>

                        
                      </div>
                  </div>
                </a>
                <div class="read-more clearfix">
                  <div class="more-left left">
                  
                    <span class="date">2015/12/29</span>
                    <span>posted in&nbsp;</span> 
          				  
          					    <span class="posted-in"><a href='Note.html'>Note</a></span>
          				   
                  </div>
                  <div class="more-right right">
                  <span class="comments">
                      

                       
                  </span>
                  </div>
                </div>
              </div><!-- article -->
        
			<div class="article">
                <a class="clearlink" href="14500612061322.html">
                
                  <h1>一日一写</h1>
                  <div class="a-content">
                      
                      <div class="a-content-text">
                        
                        	<p>2015/12/14 <a href="http://www.jianshu.com/p/158fda162794">SwizzleMethod的黑魔法</a></p>

<p>2015/12/15 <a href="http://segmentfault.com/a/1190000004153558">CloudKit入门</a></p>

<p>2015/12/16 <a href="http://segmentfault.com/a/1190000004155857">iOS后台模式教程 （一）</a></p>

<p>2015/12/17 <a href="https://github.com/zsy78191/DeviceAccessViewController">Github项目 DeviceAccessViewController</a></p>

<p>2015/12/21 <a href="http://segmentfault.com/a/1190000004176855">iOS系统授权开发</a> </p>

<p>2015/12/22 <a href="http://segmentfault.com/a/1190000004182437">iOS 本地化开发入门</a></p>

<p>2015/12/22 <a href="https://github.com/zsy78191/SimpleLocalizedTool">Github项目 SimpleLocalizedTool开源工具</a></p>

<p>2015/12/23 <a href="http://segmentfault.com/a/1190000004187941">iOS 本地化进阶教程</a></p>

<p>2015/12/24 <a href="http://segmentfault.com/a/1190000004192662">UITableView 编辑模式详解</a></p>

<p>2015/12/25 <a href="https://github.com/zsy78191/DEFetchRC">Github项目 DEFetchRC</a></p>

<p>2015/12/25 <a href="http://segmentfault.com/a/1190000004201188">NSFetchedResultsController的简单封装 － UITableView与CoreData的完美结合</a></p>

                        
                      </div>
                  </div>
                </a>
                <div class="read-more clearfix">
                  <div class="more-left left">
                  
                    <span class="date">2015/12/14</span>
                    <span>posted in&nbsp;</span> 
          				  
          					    <span class="posted-in"><a href='Note.html'>Note</a></span>
          				   
                  </div>
                  <div class="more-right right">
                  <span class="comments">
                      

                       
                  </span>
                  </div>
                </div>
              </div><!-- article -->
        
			<div class="article">
                <a class="clearlink" href="14500611755539.html">
                
                  <h1>一日一读</h1>
                  <div class="a-content">
                      
                      <div class="a-content-text">
                        
                        	<p>2015/12/14  <a href="http://blog.sunnyxx.com/tags/iOS9/">2015 Objective-C 新特性 Nullability Lightweight Generics  自定义泛型类</a>  </p>

<p>2015/12/15 <a href="http://nshipster.cn/cloudkit/">Cloud​Kit</a></p>

<p>2015/12/16 <a href="http://www.raywenderlich.com/92428/background-modes-ios-swift-tutorial">Background Modes Tutorial: Getting Started</a></p>

<p>2015/12/17 <a href="http://www.cocoachina.com/ios/20151217/14707.html">iOS：你App的设置做对了吗</a></p>

<p>2015/12/24 Effective Objective-C 2.0 一书</p>

                        
                      </div>
                  </div>
                </a>
                <div class="read-more clearfix">
                  <div class="more-left left">
                  
                    <span class="date">2015/12/14</span>
                    <span>posted in&nbsp;</span> 
          				  
          					    <span class="posted-in"><a href='Note.html'>Note</a></span>
          				   
                  </div>
                  <div class="more-right right">
                  <span class="comments">
                      

                       
                  </span>
                  </div>
                </div>
              </div><!-- article -->
        
			<div class="article">
                <a class="clearlink" href="14508363048700.html">
                
                  <h1>软件服务使用条款</h1>
                  <div class="a-content">
                      
                      <div class="a-content-text">
                        
                        	<p>感谢你使用<strong>{soft}</strong>软件及服务，你应当阅读并遵守《<strong>{soft}</strong>软件许可及服务协议》（以下简称“本协议”）的用户相关内容。若您对本声明的任何条款有异议，请停止使用<strong>{soft}</strong>所提供的全部服务。</p>

<h2 id="toc_0">个人隐私</h2>

<p>尊重用户个人隐私信息的私有性是<strong>{soft}</strong>的一贯原则，<strong>{soft}</strong>将通过技术手段、强化内部管理等办法充分保护用户的个人隐私信息，除法律或有法律赋予权限的政府部门要求或事先得到用户明确授权等原因外，<strong>{soft}</strong>保证不对外公开或向第三方透露用户个人隐私信息，或用户在使用服务时存储的非公开内容。</p>

<p>同时，为了运营和改善<strong>{soft}</strong>的技术与服务，<strong>{soft}</strong>将可能会自行收集使用或向第三方提供用户的非个人隐私信息，这将有助于<strong>{soft}</strong>向用户提供更好的用户体验和服务质量。</p>

<h2 id="toc_1">服务终止及暂停</h2>

<p>如用户滥用<strong>{soft}</strong>服务，利用<strong>{soft}</strong>平台发布广告或是垃圾信息，<strong>{soft}</strong>会行使暂停、收回、删除帐号的权利。</p>

                        
                      </div>
                  </div>
                </a>
                <div class="read-more clearfix">
                  <div class="more-left left">
                  
                    <span class="date">2015/12/23</span>
                    <span>posted in&nbsp;</span> 
          				  
          					    <span class="posted-in"><a href='Note.html'>Note</a></span>
          				   
                  </div>
                  <div class="more-right right">
                  <span class="comments">
                      

                       
                  </span>
                  </div>
                </div>
              </div><!-- article -->
        
              


			<div class="row">
			  <div class="large-6 columns">
			  <p class="text-left" style="padding-top:25px;">
			   
			  </p>
			  </div>
			  <div class="large-6 columns">
			<p class="text-right" style="padding-top:25px;">
			
			</p>
			  </div>
			</div>
		</div>
	</div><!-- large 8 -->

 <div class="large-4 medium-4 columns">
  <div class="hide-for-small">
    <div id="sidebar" class="sidebar">
          <div id="site-info" class="site-info">
            
                <h1>zsy78191</h1>
                <div class="site-des">个人博客</div>
                <div class="social">











  <a class="rss" href="atom.xml" title="RSS">RSS</a>
                
              	 </div>
          	</div>
              <div id="site-categories" class="side-item ">
                <div class="side-header">
                  <h2>Categories</h2>
                </div>
                <div class="side-content">

      	<p class="cat-list">
        
            <a href="%E5%8F%82%E8%80%83.html"><strong>参考</strong></a>
        
            <a href="Note.html"><strong>Note</strong></a>
         
        </p>


                </div>
              </div>

              <div id="site-categories" class="side-item">
                <div class="side-header">
                  <h2>Recent Posts</h2>
                </div>
                <div class="side-content">
                <ul class="posts-list">
	      
		      
			      <li class="post">
			        <a href="14543937535743.html"></a>
			      </li>
		     
		  
		      
			      <li class="post">
			        <a href="14531716978294.html">悦客接口需求</a>
			      </li>
		     
		  
		      
			      <li class="post">
			        <a href="14556955527053.html">1. 编辑地址接口，总是返回 ‘手机号填写有误哦’</a>
			      </li>
		     
		  
		      
			      <li class="post">
			        <a href="14502520092955.html">Background Modes Tutorial: Getting Started</a>
			      </li>
		     
		  
		      
			      <li class="post">
			        <a href="14561077487642.html">HTML</a>
			      </li>
		     
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		   
		  		</ul>
                </div>
              </div>
        </div><!-- sidebar -->
      </div><!-- hide for small -->
</div><!-- large 4 -->

</div><!-- row -->

 <div class="page-bottom clearfix">
  <div class="row">
   <p class="copyright">Copyright &copy; 2015
Powered by <a target="_blank" href="http://www.mweb.im">MWeb</a>,&nbsp; 
Theme used <a target="_blank" href="http://github.com">GitHub CSS</a>.</p>
  </div>
</div>

        </section>
      </div>
    </div>

  
    

    <script src="asset/js/foundation.min.js"></script>
    <script>
      $(document).foundation();
      function fixSidebarHeight(){
        var w1 = $('.markdown-body').height();
          var w2 = $('#sidebar').height();
          if (w1 > w2) { $('#sidebar').height(w1); };
      }
      $(function(){
        fixSidebarHeight();
      })
      $(window).load(function(){
          fixSidebarHeight();
      });
     
    </script>

    



  </body>
</html>
